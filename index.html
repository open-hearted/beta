<!-- 2025-08-10 ‰ΩúÊàê ÂêÑ„Çª„ÇØ„Ç∑„Éß„É≥„Å´Áô∫Èü≥Ë©ï‰æ°Ê©üËÉΩ„ÇíÂê´„ÇÄ -->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title></title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* make sizing predictable and avoid horizontal overflow */
    *, *::before, *::after { box-sizing: border-box; }
    html, body { overflow-x: hidden; }
  body { font-family: sans-serif; padding: 1rem; background: #f0f2f5; max-width: none; width: 100%; margin: 0; line-height: 1.6; }
  .full-audio-block { max-width: 820px; margin: 0 auto 2.5rem auto; background: #fff; border: 1px solid #e5e7eb; border-radius: 12px; padding: 1.25rem 1.5rem; box-shadow: 0 6px 12px rgba(15,23,42,0.06); }
  .full-audio-title { margin: 0 0 0.4rem 0; font-size: 1.35rem; color: #1f2937; text-align: center; }
  .full-audio-caption { margin: 0 0 1rem 0; font-size: 0.95rem; color: #4b5563; text-align: center; }
    .card { background: transparent; border: none; padding: 0; margin-bottom: 2rem; box-shadow: none; }
    .entry { border: 1px solid #ddd; border-radius: 12px; background: #fff; overflow: hidden; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05); }
  .entry summary { position: relative; list-style: none; display: flex; align-items: center; gap: 12px; flex-wrap: wrap; padding: 1rem 1.25rem; background: #f7f8fc; cursor: pointer; font-weight: 600; color: #1f2937; }
  .entry summary::before { content: '\25B6'; color: #6366f1; font-size: 0.85rem; transition: transform 0.2s ease; }
  .entry.expanded summary::before,
  .entry[open] summary::before { transform: rotate(90deg); }
    .entry summary::-webkit-details-marker { display: none; }
    .entry.expanded summary,
    .entry[open] summary { border-bottom: 1px solid #e5e7eb; background: #eef2ff; }
  .entry-title { flex: 0 0 auto; font-size: 1.05rem; }
    .entry-snippet { flex: 2 1 240px; font-size: 0.95rem; color: #6b7280; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .entry-status { position: absolute; left: 50%; transform: translateX(-50%); font-size: 0.9rem; color: #374151; white-space: nowrap; }
    .entry-body { padding: 1.25rem; background: white; }
    h1 { font-size: 2rem; color: #333; margin-bottom: 1rem; text-align: center; }
    h2 { font-size: 1.3rem; color: #555; margin-bottom: 1rem; border-bottom: 2px solid #eee; padding-bottom: 0.5rem; }
    h3 { font-size: 1.1rem; color: #666; margin-bottom: 0.8rem; }
    input[type="text"], input[type="file"], textarea { width: 100%; padding: 0.7rem; margin: 0.5rem 0; font-size: 1rem; border: 2px solid #ddd; border-radius: 6px; box-sizing: border-box; transition: border-color 0.3s; }
    button { background-color: #4caf50; color: white; border: none; padding: 0.7rem 1.2rem; font-size: 1rem; border-radius: 6px; cursor: pointer; margin: 0.3rem 0.5rem 0.3rem 0; transition: background-color 0.3s; }
    button:hover { background-color: #45a049; }
    button:disabled { background-color: #ccc; cursor: not-allowed; }
    audio { width: 100%; margin: 1rem 0; border-radius: 6px; }
    .subtitle { font-size: 1.4rem; margin-bottom: 1.5rem; }
    .status { margin-top: 0.5rem; font-size: 1rem; color: #333; }
    .collapsible { background-color: #eee; cursor: pointer; padding: 0.5rem 1rem; border: none; font-size: 0.95rem; margin-top: 0.8rem; width: 100%; border-radius: 6px; text-align: left; }
    .collapsible:hover { background-color: #ddd; }
  .content { display: none; background-color: #fafafa; padding: 1rem; border: 1px solid #ccc; margin-top: 0.5rem; border-radius: 6px; white-space: pre-wrap; }
  .pending-preview { display: none; margin-top: 0.75rem; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 8px; background: #fff; }
  .pending-preview audio { flex: 1 1 auto; width: auto; min-width: 180px; }
  .pending-preview-row { display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
  .pending-preview-header { font-weight: 600; font-size: 0.95rem; color: #1f2937; margin-bottom: 0.5rem; }
  .pending-preview button { background-color: #ef4444; }
  .pending-preview button:hover { background-color: #dc2626; }
  .evaluation-block { background: #f9fafb; border: 1px solid #d1d5db; border-radius: 10px; padding: 1rem; margin-top: 1rem; }
  .evaluation-header { display: flex; align-items: center; gap: 0.75rem; margin: 0 0 0.5rem 0; }
  .evaluation-title { margin: 0; font-size: 1.1rem; color: #374151; }
  .evaluation-header button { margin: 0 0 0 auto; }
  .pronunciation-controls { display: flex; gap: 8px; align-items: center; margin-top: 8px; flex-wrap: wrap; }
  .pronunciation-controls .rec-toggle { display: inline-flex; align-items: center; gap: 6px; padding: 0.65rem 1.1rem; background-color: #2563eb; }
  .pronunciation-controls .rec-toggle.recording { background-color: #dc2626; }
  .pronunciation-controls .pronunciation-submit { margin-left: auto; }
  .evaluation-history { margin-top: 0.75rem; border-top: 1px dashed #d1d5db; padding-top: 0.75rem; display: flex; flex-direction: column; gap: 0.75rem; }
  .history-entry { background: #fff; border: 1px solid #e5e7eb; border-radius: 8px; padding: 0.75rem; display: flex; flex-direction: column; gap: 0.5rem; }
  .history-entry-header { display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; color: #6b7280; }
  .history-row { display: flex; gap: 0.5rem; align-items: flex-start; }
  .history-label { font-weight: 600; min-width: 3rem; color: #374151; font-size: 0.9rem; }
  .history-text { flex: 1 1 auto; white-space: pre-wrap; word-break: break-word; font-size: 0.95rem; color: #1f2937; }
  .history-empty { font-size: 0.9rem; color: #6b7280; }
  .auth-bar { display: flex; align-items: center; justify-content: space-between; gap: 12px; background: #1f2937; color: #f9fafb; padding: 0.6rem 0.9rem; border-radius: 8px; max-width: 820px; margin: 0 auto 1.5rem auto; }
  .auth-bar.hidden { display: none; }
  .auth-bar button { background: #ef4444; }
  .auth-bar button:hover { background: #dc2626; }
    #scoreBlock { margin: 1rem 0; text-align: center; }
    #wordsBlock { margin-top: 1rem; }
    table { width: 100%; border-collapse: collapse; text-align: left; }
    th, td { border: 1px solid #ddd; padding: 0.5rem; }
    th { background: #f8f9fa; }
  /* recording card layout */
  .rec-card { display:flex; gap:12px; align-items:flex-start; background: #fff; border-radius:8px; padding:8px; width:100%; box-sizing:border-box; flex-wrap:wrap; }
  .rec-card .left { display:flex; align-items:center; justify-content:flex-start; flex:0 0 auto; gap:10px; }
  .rec-card .right { flex:1 1 auto; min-width:0; }
  .rec-card canvas { background:transparent; }
  .word-table { margin-top:8px; font-size:0.92rem; border-top:1px dashed #eee; padding-top:8px; }
    @media (max-width: 768px) { body { padding: 0.5rem; } .card { padding: 1rem; } h1 { font-size: 1.5rem; } button { padding: 0.6rem 1rem; font-size: 0.9rem; } }
  </style>
</head>
<body>

<h1>ÊØéÊó•„ÅåÊàêÈï∑Êó•Ôºö„É™„Çπ„Éã„É≥„Ç∞ÔºÜÁô∫Èü≥„Éà„É¨„Éº„Éã„É≥„Ç∞ÈÅìÂ†¥</h1>
<div id="authBar" class="auth-bar hidden">
  <span id="authUserDisplay"></span>
  <button id="logoutBtn" type="button">„É≠„Ç∞„Ç¢„Ç¶„Éà</button>
</div>
<div class="full-audio-block">
  <h2 class="full-audio-title">„ÅäÊâãÊú¨„Éã„É•„Éº„ÇπÈü≥Â£∞</h2>
  <p class="full-audio-caption">„Åæ„Åö„ÅØ„Éã„É•„Éº„ÇπÂÖ®‰Ωì„ÇíÈÄö„Åó„Å¶ËÅû„Åç„ÄÅÁô∫Èü≥„ÇÑ„É™„Ç∫„É†„ÇíÁ¢∫Ë™ç„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ</p>
  <audio controls src="" id="fullAudio" style="width: 100%; display: block;"></audio>
</div>
<div id="sentence-sections"></div>

<script>
'use strict';
// ‰æãÊñáÔºàÈÅ©ÂÆúÂ§âÊõ¥ÂèØÔºâ
const sentences = [
  "Many iPhones and other Apple products are made in China.",
  "In recent years, Apple has expanded its manufacturing into other countries such as Vietnam and India.",
  "But not so much to the United States.",
  "That is changing.",
  "This week, Apple said that over the next 4 years it would invest $500 billion in the US with plans that include building a Texas facility to manufacture artificial intelligence servers and commit to creating 20,000 US jobs.",
  "Apple's announcement follows a meeting last week between CEO Tim Cook and President Donald Trump.",
  "The iPhone maker is among US firms recently announcing domestic investment and job creation.",
  "\"...and they're going to build here instead because they don't want to pay the tariffs.\"",
  "In a social media post on Thursday, Trump doubled the 10% universal tariff imposed on China, effective Tuesday.",
  "Observers say that Apple's move is part of its trend to diversify its supply chain and it's not related to Trump's tariffs on China.",
  "I mean, they are now in the, in, have been for some years, i.., in the process of , uh, moving production away from China anyway, uh,  pre-tariff.",
  "There's still a substantial amount in China, but, uhm.",
  "Th, there's a trend here that's clear, and I think that Apple will continue that.",
  "While much of Apple's plans had been known, the company is signaling its pro-US jobs and investment policy, a priority for the Trump administration.",
  "They're just taking the opportunity to use, ??????, the press releases to try to just get some more public exposure for a lot of things they were already spending and and obviously align well with kind of a pro, pro US policy.",
  "As part of its US investment, Apple said it would produce its advanced silicon chips in the Arizona plant of TSMC, the Taiwanese semiconductor firm.",
  "Michelle Quinn, VOA news."
];
const audioFolderName = "With $500B US investment, Apple pulling away from China, analysts say";
// Encode folder name so static hosts serve files even with spaces/symbols in path
const base = `./${encodeURIComponent(audioFolderName)}`;
const container = document.getElementById("sentence-sections");

// Set up full audio player
const fullAudio = document.getElementById("fullAudio");
if (fullAudio) {
  fullAudio.src = `${base}/full_audio.mp3`;
}

const AUTH_STORAGE_KEY = 'ela_auth_session';
const authState = { token: null, userId: null, expiresAt: 0 };
let PAGE_PREFIX = '';
let currentAuthUserId = null;
const PASSWORD_OPTIONAL_PREFIX = 'acg2_';

function sanitizeUserIdForClient(id) {
  return String(id || '').trim().replace(/[^A-Za-z0-9._-]/g, '_');
}

function setAuthState(token, userId, expiresAt) {
  authState.token = token;
  authState.userId = userId;
  authState.expiresAt = expiresAt;
  try {
    const payload = JSON.stringify({ token, userId, expiresAt });
    localStorage.setItem(AUTH_STORAGE_KEY, payload);
  } catch (e) {
    console.warn('persist auth failed', e);
  }
  updateAuthBar();
}

function clearAuthState() {
  authState.token = null;
  authState.userId = null;
  authState.expiresAt = 0;
  try { localStorage.removeItem(AUTH_STORAGE_KEY); } catch {}
  updateAuthBar();
}

function loadAuthFromStorage() {
  try {
    const raw = localStorage.getItem(AUTH_STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') return null;
    if (!parsed.token || !parsed.userId || !parsed.expiresAt) return null;
    return parsed;
  } catch (e) {
    console.warn('load auth storage failed', e);
    return null;
  }
}

function getStorageNamespace() {
  return authState.userId ? `user_${sanitizeUserIdForClient(authState.userId)}` : 'anon';
}

function namespacedKey(base) {
  return `${getStorageNamespace()}::${base}`;
}

function storageGet(baseKey) {
  try {
    return localStorage.getItem(namespacedKey(baseKey));
  } catch (e) {
    console.warn('storageGet failed', e);
    return null;
  }
}

function storageSet(baseKey, value) {
  try {
    localStorage.setItem(namespacedKey(baseKey), value);
  } catch (e) {
    console.warn('storageSet failed', e);
  }
}

function storageRemove(baseKey) {
  try {
    localStorage.removeItem(namespacedKey(baseKey));
  } catch (e) {
    console.warn('storageRemove failed', e);
  }
}

function purgeUserScopedData(userId) {
  if (!userId) return;
  const prefix = `user_${sanitizeUserIdForClient(userId)}::`;
  try {
    const targets = [];
    for (let i = 0; i < localStorage.length; i += 1) {
      const key = localStorage.key(i);
      if (key && key.startsWith(prefix)) targets.push(key);
    }
    targets.forEach(key => {
      try { localStorage.removeItem(key); } catch (err) { console.warn('purgeUserScopedData remove failed', err); }
    });
  } catch (e) {
    console.warn('purgeUserScopedData failed', e);
  }
}

function updateAuthBar() {
  const bar = document.getElementById('authBar');
  if (!bar) return;
  const label = document.getElementById('authUserDisplay');
  const logoutBtn = document.getElementById('logoutBtn');
  if (authState.userId) {
    if (label) label.textContent = `„É≠„Ç∞„Ç§„É≥‰∏≠: ${authState.userId}`;
    bar.classList.remove('hidden');
    if (logoutBtn) logoutBtn.disabled = false;
  } else {
    if (label) label.textContent = '';
    bar.classList.add('hidden');
    if (logoutBtn) logoutBtn.disabled = false;
  }
}

function logoutUser(options = {}) {
  const currentUser = authState.userId;
  if (currentUser) {
    purgeUserScopedData(currentUser);
  }
  clearAuthState();
  PAGE_PREFIX = '';
  currentAuthUserId = null;
  if (!options || options.silent !== true) {
    try {
      window.location.reload();
    } catch (e) {
      console.warn('reload failed after logout', e);
      promptForLogin();
    }
  }
}

const EVAL_HISTORY_LIMIT = 20;
const LISTENING_EVAL_LIMIT = 10;
const TRANSLATION_EVAL_LIMIT = 10;
const PRONUNCIATION_EVAL_LIMIT = 10;

function evaluationHistoryKey(type, idx) {
  return `${type}History_${idx}`;
}

function sanitizeHistoryEntry(entry) {
  if (!entry || typeof entry !== 'object') return null;
  const input = String(entry.input ?? entry.listen ?? entry.student ?? '').trim();
  const feedback = String(entry.feedback ?? entry.result ?? entry.response ?? '').trim();
  if (!input && !feedback) return null;
  const rawTs = entry.createdAt || entry.savedAt || entry.timestamp || entry.time;
  let iso = null;
  if (rawTs) {
    const parsed = new Date(rawTs);
    if (!Number.isNaN(parsed.getTime())) iso = parsed.toISOString();
  }
  if (!iso) iso = new Date().toISOString();
  return { input, feedback, createdAt: iso };
}

function loadEvaluationHistory(type, idx) {
  const raw = storageGet(evaluationHistoryKey(type, idx));
  if (!raw) return [];
  try {
    const parsed = JSON.parse(raw);
    if (Array.isArray(parsed)) {
      return parsed
        .map(sanitizeHistoryEntry)
        .filter(Boolean)
        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
    }
  } catch (e) {
    console.warn('loadEvaluationHistory parse failed', e);
  }
  return [];
}

function saveEvaluationHistory(type, idx, history) {
  const clean = Array.isArray(history)
    ? history.map(sanitizeHistoryEntry).filter(Boolean)
    : [];
  try {
    storageSet(evaluationHistoryKey(type, idx), JSON.stringify(clean.slice(0, EVAL_HISTORY_LIMIT)));
  } catch (e) {
    console.warn('saveEvaluationHistory failed', e);
  }
}

function mergeHistoryEntries(primaryEntries, secondaryEntries = []) {
  const merged = [];
  const seen = new Set();
  const pushEntry = (entry) => {
    const clean = sanitizeHistoryEntry(entry);
    if (!clean) return;
    const key = `${clean.createdAt}__${clean.input}__${clean.feedback}`;
    if (seen.has(key)) return;
    seen.add(key);
    merged.push(clean);
  };
  [...(Array.isArray(primaryEntries) ? primaryEntries : []), ...(Array.isArray(secondaryEntries) ? secondaryEntries : [])].forEach(pushEntry);
  merged.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  return merged.slice(0, EVAL_HISTORY_LIMIT);
}

function formatHistoryTimestamp(isoString) {
  if (!isoString) return '';
  const d = new Date(isoString);
  if (Number.isNaN(d.getTime())) return '';
  try {
    return d.toLocaleString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
  } catch (e) {
    return d.toISOString();
  }
}

function renderEvaluationHistory(type, idx, entries) {
  const container = document.getElementById(`${type}History_${idx}`);
  if (!container) return;
  const history = Array.isArray(entries) ? entries : loadEvaluationHistory(type, idx);
  container.innerHTML = '';
  if (!history.length) {
    const empty = document.createElement('div');
    empty.className = 'history-empty';
    empty.textContent = type === 'translation' ? '„Åæ„Å†ÁøªË®≥Ë©ï‰æ°„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ' : '„Åæ„Å†„É™„Çπ„Éã„É≥„Ç∞Ë©ï‰æ°„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ';
    container.appendChild(empty);
    return;
  }
  history.forEach(entry => {
    const wrapper = document.createElement('div');
    wrapper.className = 'history-entry';

    const header = document.createElement('div');
    header.className = 'history-entry-header';
    const timeEl = document.createElement('time');
    timeEl.textContent = formatHistoryTimestamp(entry.createdAt) || 'Êó•ÊôÇ‰∏çÊòé';
    header.appendChild(timeEl);
    wrapper.appendChild(header);

    const inputRow = document.createElement('div');
    inputRow.className = 'history-row';
    const inputLabel = document.createElement('span');
    inputLabel.className = 'history-label';
    inputLabel.textContent = 'ÂÖ•Âäõ';
    const inputText = document.createElement('div');
    inputText.className = 'history-text';
    inputText.textContent = entry?.input || '';
    inputRow.appendChild(inputLabel);
    inputRow.appendChild(inputText);
    wrapper.appendChild(inputRow);

    const feedbackRow = document.createElement('div');
    feedbackRow.className = 'history-row';
    const feedbackLabel = document.createElement('span');
    feedbackLabel.className = 'history-label';
    feedbackLabel.textContent = 'Ë©ï‰æ°';
    const feedbackText = document.createElement('div');
    feedbackText.className = 'history-text';
    feedbackText.textContent = entry?.feedback || '';
    feedbackRow.appendChild(feedbackLabel);
    feedbackRow.appendChild(feedbackText);
    wrapper.appendChild(feedbackRow);

    container.appendChild(wrapper);
  });
}

function appendEvaluationHistory(type, idx, input, feedback, createdAt = null, options = {}) {
  const baseEntry = sanitizeHistoryEntry({ input, feedback, createdAt });
  if (!baseEntry) return;
  const current = loadEvaluationHistory(type, idx);
  if (!options.allowDuplicate) {
    const exists = current.some(entry => entry.input === baseEntry.input && entry.feedback === baseEntry.feedback && entry.createdAt === baseEntry.createdAt);
    if (exists) {
      renderEvaluationHistory(type, idx, current);
      return;
    }
  }
  const merged = mergeHistoryEntries([baseEntry, ...current]);
  saveEvaluationHistory(type, idx, merged);
  renderEvaluationHistory(type, idx, merged);
}

function getEvaluationHistoryCount(type, idx) {
  return loadEvaluationHistory(type, idx).length;
}

function pronunciationAttemptsKey(idx) {
  return `pronunciationAttempts_${idx}`;
}

function getStoredPronunciationAttempts(idx) {
  const raw = storageGet(pronunciationAttemptsKey(idx));
  const n = Number(raw);
  return Number.isFinite(n) && n >= 0 ? Math.floor(n) : 0;
}

function setPronunciationAttempts(idx, count) {
  storageSet(pronunciationAttemptsKey(idx), String(Math.max(0, Math.floor(count))));
}

function getPronunciationAssessmentCount(idx) {
  const recList = document.getElementById(`recList_${idx}`);
  if (!recList) return 0;
  return Array.from(recList.querySelectorAll('.rec-card')).filter(card => card.dataset.assessed === 'true').length;
}

function getPronunciationAttempts(idx) {
  return Math.max(getStoredPronunciationAttempts(idx), getPronunciationAssessmentCount(idx));
}

function incrementPronunciationAttempts(idx) {
  const currentStored = getStoredPronunciationAttempts(idx);
  const assessedCount = getPronunciationAssessmentCount(idx);
  const next = Math.max(currentStored + 1, assessedCount);
  setPronunciationAttempts(idx, next);
  return next;
}

function isPronunciationLimitReached(idx) {
  try {
    return getPronunciationAttempts(idx) >= PRONUNCIATION_EVAL_LIMIT;
  } catch (e) {
    console.warn('isPronunciationLimitReached failed', e);
    return false;
  }
}

function computePagePrefix() {
  const safeUser = sanitizeUserIdForClient(authState.userId || 'anon');
  let p = location.host + location.pathname;
  p = p.replace(/[^A-Za-z0-9._\-/]/g, '_');
  if (!p.endsWith('/')) p += '/';
  return `${safeUser}/${p}`;
}

async function validateToken() {
  if (!authState.token) return false;
  try {
    const res = await fetch('/api/auth', {
      method: 'GET',
      headers: { Authorization: `Bearer ${authState.token}` }
    });
    if (!res.ok) return false;
    const data = await res.json().catch(() => null);
    if (!data || !data.userId) return false;
    authState.userId = data.userId;
    if (data.expiresAt) authState.expiresAt = data.expiresAt;
  updateAuthBar();
    return true;
  } catch (e) {
    console.warn('token validation failed', e);
    return false;
  }
}

function buildLoginOverlay() {
  const overlay = document.createElement('div');
  overlay.id = 'authOverlay';
  overlay.style = `position:fixed;inset:0;background:rgba(17,24,39,0.85);display:flex;align-items:center;justify-content:center;z-index:9999;`;
  overlay.innerHTML = `
    <div style="background:#fff;border-radius:12px;padding:24px;max-width:360px;width:92%;box-shadow:0 12px 30px rgba(0,0,0,0.25);">
      <h2 style="margin:0 0 16px 0;font-size:1.25rem;color:#111827;text-align:center;">„É≠„Ç∞„Ç§„É≥</h2>
      <form id="authForm" style="display:flex;flex-direction:column;gap:12px;">
        <label style="display:flex;flex-direction:column;font-size:0.95rem;color:#374151;gap:4px;">
          „É¶„Éº„Ç∂„ÉºID
          <input type="text" name="userId" required style="padding:0.6rem;border:1px solid #d1d5db;border-radius:6px;font-size:1rem;" autocomplete="username" />
        </label>
        <label class="auth-password-field" style="display:flex;flex-direction:column;font-size:0.95rem;color:#374151;gap:4px;">
          „Éë„Çπ„ÉØ„Éº„Éâ
          <input type="password" name="password" required style="padding:0.6rem;border:1px solid #d1d5db;border-radius:6px;font-size:1rem;" autocomplete="current-password" />
          <span class="auth-password-hint" style="display:none;font-size:0.8rem;color:#6b7280;">acg2_„ÅßÂßã„Åæ„ÇãID„ÅØ„Éë„Çπ„ÉØ„Éº„Éâ‰∏çË¶Å„Åß„Åô„ÄÇ</span>
        </label>
        <button type="submit" style="margin-top:4px;background:#2563eb;color:#fff;padding:0.65rem;border-radius:6px;font-size:1rem;font-weight:600;border:none;cursor:pointer;">„É≠„Ç∞„Ç§„É≥</button>
        <div id="authStatus" style="min-height:1.2rem;font-size:0.9rem;color:#dc2626;text-align:center;"></div>
      </form>
    </div>
  `;
  return overlay;
}

async function promptForLogin() {
  return new Promise(resolve => {
    const overlay = buildLoginOverlay();
    document.body.appendChild(overlay);
    const form = overlay.querySelector('#authForm');
    const statusEl = overlay.querySelector('#authStatus');
    const userInput = form?.querySelector('input[name="userId"]');
    const passwordInput = form?.querySelector('input[name="password"]');
    const passwordHint = form?.querySelector('.auth-password-hint');
    const togglePasswordState = (value) => {
      const raw = typeof value === 'string' ? value.trim() : '';
      const optional = raw.startsWith(PASSWORD_OPTIONAL_PREFIX);
      if (passwordInput) {
        passwordInput.disabled = optional;
        passwordInput.required = !optional;
        if (optional) passwordInput.value = '';
      }
      if (passwordHint) passwordHint.style.display = optional ? 'block' : 'none';
    };
    if (userInput) {
      togglePasswordState(userInput.value);
      userInput.addEventListener('input', (ev) => togglePasswordState(ev.target.value));
    }
    let busy = false;
    form.addEventListener('submit', async (ev) => {
      ev.preventDefault();
      if (busy) return;
      busy = true;
      statusEl.textContent = '';
      const formData = new FormData(form);
      const userId = String(formData.get('userId') || '').trim();
      const password = String(formData.get('password') || '');
      const passwordOptional = userId.startsWith(PASSWORD_OPTIONAL_PREFIX);
      if (!userId) {
        statusEl.textContent = '„É¶„Éº„Ç∂„ÉºID„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ';
        busy = false;
        return;
      }
      if (!passwordOptional && !password) {
        statusEl.textContent = '„Åì„ÅÆID„Å´„ÅØ„Éë„Çπ„ÉØ„Éº„Éâ„ÅåÂøÖË¶Å„Åß„Åô';
        busy = false;
        return;
      }
      try {
        const res = await fetch('/api/auth', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userId, password: passwordOptional ? '' : password })
        });
        if (!res.ok) {
          const text = await res.text();
          let msg = 'Ë™çË®º„Å´Â§±Êïó„Åó„Åæ„Åó„Åü';
          try {
            const parsed = JSON.parse(text);
            if (parsed && parsed.error) msg = parsed.error;
          } catch {}
          statusEl.textContent = msg;
          busy = false;
          return;
        }
        const data = await res.json();
        const now = Date.now();
        const expiresInMs = (data.expiresIn || 3600) * 1000;
        setAuthState(data.token, data.userId, now + expiresInMs);
        overlay.remove();
        resolve(authState);
      } catch (e) {
        console.warn('login request failed', e);
        statusEl.textContent = '„Çµ„Éº„Éê„Éº„Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü';
        busy = false;
      }
    });
  });
}

async function ensureAuthenticated() {
  const now = Date.now();
  if (authState.token && authState.expiresAt && authState.expiresAt > now + 5000) {
    return authState;
  }
  const stored = loadAuthFromStorage();
  if (stored && stored.token) {
    authState.token = stored.token;
    authState.userId = stored.userId;
    authState.expiresAt = stored.expiresAt;
    if (stored.expiresAt && stored.expiresAt > Date.now() + 5000) {
      const ok = await validateToken();
      if (ok) return authState;
    }
  }
  clearAuthState();
  return promptForLogin();
}

async function authedFetch(input, init = {}, retry = true) {
  await ensureAuthenticated();
  const options = Object.assign({}, init || {});
  const headers = new Headers(options.headers || {});
  if (authState.token) headers.set('Authorization', `Bearer ${authState.token}`);
  options.headers = headers;
  const response = await fetch(input, options);
  if (response.status === 401 && retry) {
    clearAuthState();
    await ensureAuthenticated();
    PAGE_PREFIX = computePagePrefix();
    currentAuthUserId = authState.userId;
    window.location.reload();
    throw new Error('„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÂàá„Çå„Åü„Åü„ÇÅ„Éö„Éº„Ç∏„ÇíÂÜçË™≠„ÅøËæº„Åø„Åó„Åæ„Åô');
  }
  return response;
}

function requireAuthGuard() {
  if (!authState.userId) {
    throw new Error('Ë™çË®ºÊÉÖÂ†±„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
  }
}

function updateEntrySummary(idx) {
  const statusEl = document.getElementById(`status${idx}`);
  const snippetEl = document.getElementById(`summarySnippet_${idx}`);
  const entryEl = document.querySelector(`.entry[data-section="${idx}"]`);
  if (!statusEl && !snippetEl) return;

  const noteInput = document.getElementById(`note_${idx}_input`);
  const transInput = document.getElementById(`trans_${idx}_input`);
  const noteVal = (noteInput?.value || "").trim();
  const transVal = (transInput?.value || "").trim();

  let listeningHistoryCount = 0;
  let translationHistoryCount = 0;
  try { listeningHistoryCount = getEvaluationHistoryCount('listening', idx); } catch (e) {}
  try { translationHistoryCount = getEvaluationHistoryCount('translation', idx); } catch (e) {}

  const recList = document.getElementById(`recList_${idx}`);
  const recCount = recList ? recList.querySelectorAll('.rec-card').length : 0;
  const syncText = document.getElementById(`syncStatus_${idx}`)?.textContent?.trim() || "";
  const isDirty = entryEl?.dataset?.dirty === '1';

  const listeningDone = listeningHistoryCount > 0;
  const translationDone = translationHistoryCount > 0;
  const recordingDone = recCount > 0;
  if (statusEl) {
    const statuses = [
      `ËÅû„ÅçÂèñ„Çä${listeningDone ? '‚úÖ' : '‚¨ú'}`,
      `ÂíåË®≥${translationDone ? '‚úÖ' : '‚¨ú'}`,
      `Èå≤Èü≥${recordingDone ? '‚úÖ' : '‚¨ú'}`
    ];
    statusEl.textContent = statuses.join('„ÄÄ');
    const extras = [];
    if (isDirty) extras.push('Êú™‰øùÂ≠ò„ÅÆÂ§âÊõ¥„ÅÇ„Çä');
    if (/‰øùÂ≠ò‰∏≠/.test(syncText)) extras.push('‰øùÂ≠ò‰∏≠');
    else if (/‰øùÂ≠òÊ∏à/.test(syncText) || /Ë™≠„ÅøËæº„Åø/.test(syncText)) extras.push('„Çµ„Éº„Éê„Éº„Å®ÂêåÊúüÊ∏à„Åø');
    else if (/Â§±Êïó/.test(syncText)) extras.push('‰øùÂ≠ò„Å´Â§±Êïó');
    else if (/„ÅÇ„Çä„Åæ„Åõ„Çì/.test(syncText)) extras.push('„Çµ„Éº„Éê„Éº„Éá„Éº„Çø„Å™„Åó');
    statusEl.title = extras.length ? extras.join(' / ') : '';
  }

  if (snippetEl) {
    snippetEl.textContent = '';
    snippetEl.style.display = 'none';
  }
}

const totalSections = sentences.length;

function buildSections() {
  requireAuthGuard();
  container.innerHTML = '';
  sentences.forEach((sentence, idx) => {
    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
    <details class="entry" data-section="${idx}">
      <summary>
        <span class="entry-title">${idx + 1}/${totalSections}</span>
        <span class="entry-status" id="status${idx}">ËÅû„ÅçÂèñ„Çä‚¨ú„ÄÄÂíåË®≥‚¨ú„ÄÄÈå≤Èü≥‚¨ú</span>
        <span class="entry-snippet" id="summarySnippet_${idx}" style="display:none;"></span>
      </summary>
      <div class="entry-body">
        <audio controls src="${base}/${idx + 1}.mp3"></audio>
        <div id="syncStatus_${idx}" style="font-size:0.9rem;color:#4b5563;margin-bottom:10px"></div>
    <button class="collapsible script-toggle primary-script">üìú „Çπ„ÇØ„É™„Éó„Éà„ÇíË°®Á§∫</button>
    <div class="content script-content primary-script-content" style="display:none;"></div>
        <div class="evaluation-block listening-block">
          <div class="evaluation-header">
            <h3 class="evaluation-title">„É™„Çπ„Éã„É≥„Ç∞Ë©ï‰æ°</h3>
            <button id="note_${idx}_compare">„É™„Çπ„Éã„É≥„Ç∞Ë©ï‰æ°</button>
          </div>
          <textarea id="note_${idx}_input" placeholder="ËÅû„Åì„Åà„ÅüÊñá„ÇíÂÖ•Âäõ‚Ä¶"></textarea>
          <div class="evaluation-history" id="listeningHistory_${idx}"></div>
        </div>
        <div class="evaluation-block translation-block">
          <div class="evaluation-header">
            <h3 class="evaluation-title">ÁøªË®≥Ë©ï‰æ°</h3>
            <button id="trans_${idx}_compare">ÁøªË®≥Ë©ï‰æ°</button>
          </div>
          <textarea id="trans_${idx}_input" placeholder="Êó•Êú¨Ë™ûË®≥„ÇíÂÖ•Âäõ‚Ä¶"></textarea>
          <div class="evaluation-history" id="translationHistory_${idx}"></div>
        </div>
        <div class="evaluation-block pronunciation-block">
          <div class="evaluation-header">
            <h3 class="evaluation-title">Áô∫Èü≥Ë©ï‰æ°</h3>
          </div>
          <audio controls src="${base}/${idx + 1}.mp3" class="sample-audio" style="margin-top:0.5rem;margin-bottom:0.5rem;"></audio>
          <button class="collapsible script-toggle secondary-script">üìú „Çπ„ÇØ„É™„Éó„Éà„ÇíË°®Á§∫</button>
          <div class="content script-content secondary-script-content" style="display:none;"></div>
          <div class="pronunciation-controls">
            <button id="recToggle_${idx}" class="rec-toggle">üéôÔ∏è Èå≤Èü≥ÈñãÂßã</button>
            <span id="recStatus_${idx}" style="margin-left:8px;color:#4b5563;font-size:0.95rem;"></span>
            <span id="recTimer_${idx}" style="margin-left:8px;color:#b91c1c;font-weight:600;"></span>
            <button id="submitBtn_${idx}" class="pronunciation-submit" disabled>Áô∫Èü≥Ë©ï‰æ°„ÇíÂÆüË°å</button>
          </div>
          <pre id="result_${idx}" style="margin:0;padding:0;"></pre>
          <div id="pendingPreview_${idx}" class="pending-preview"></div>
          <div id="recList_${idx}" style="margin-top:10px;"></div>
          <div id="scoreBlock_${idx}"></div>
        </div>
      </div>
    </details>
    `;
    container.appendChild(card);
    setupBlock(idx, sentence);
  });
}

function setupBlock(idx, sentence) {
  const cardRoot = container.children[idx];
  const entryEl = cardRoot?.querySelector(".entry");
  const primaryScriptBtn = cardRoot?.querySelector(".primary-script");
  const primaryScriptContent = cardRoot?.querySelector(".primary-script-content");
  const secondaryScriptBtn = cardRoot?.querySelector(".secondary-script");
  const secondaryScriptContent = cardRoot?.querySelector(".secondary-script-content");

  const noteInput = document.getElementById(`note_${idx}_input`);
  const transInput = document.getElementById(`trans_${idx}_input`);
  const submitBtn = document.getElementById(`submitBtn_${idx}`);
  const pendingPreview = document.getElementById(`pendingPreview_${idx}`);
  let pendingPreviewUrl = null;
  const recToggleBtn = document.getElementById(`recToggle_${idx}`);

  if (entryEl) entryEl.dataset.dirty = '0';

  if (entryEl) {
    entryEl.addEventListener("toggle", () => {
      entryEl.classList.toggle("expanded", entryEl.open);
      if (entryEl.open) {
        container.querySelectorAll('.entry').forEach(section => {
          if (section !== entryEl && section.open) section.open = false;
        });
        fetchRemoteNotes(true);
        fetchAssessmentsForSection(true);
        setTimeout(() => {
          document.getElementById(`note_${idx}_input`)?.focus({ preventScroll: false });
        }, 50);
      } else {
        saveNotesToServer(idx);
      }
      updateEntrySummary(idx);
    });
  }

  if (primaryScriptContent) primaryScriptContent.textContent = sentence;
  if (secondaryScriptContent) secondaryScriptContent.textContent = sentence;
  noteInput.value = storageGet(`note_${idx}`) || "";
  transInput.value = storageGet(`trans_${idx}`) || "";
  renderEvaluationHistory('listening', idx);
  renderEvaluationHistory('translation', idx);
  updateEntrySummary(idx);
  setTimeout(() => {
    fetchAssessmentsForSection().catch(err => console.warn('prefetch assessments failed', err));
  }, idx * 150);

  let remoteNoteLoading = false;
  let notesLoaded = false;
  let notesDirty = false;
  let assessmentsLoaded = false;
  let assessmentLoading = false;

  async function fetchRemoteNotes(force = false) {
    if (remoteNoteLoading) return;
    if (notesLoaded && !force) return;
    remoteNoteLoading = true;
    const syncEl = document.getElementById(`syncStatus_${idx}`);
    try {
  const pagePrefix = PAGE_PREFIX || computePagePrefix();
  const sidecarKey = pagePrefix + `notes_section_${idx}.assessment.json`;
  const resp = await authedFetch(`/api/assessment?key=${encodeURIComponent(sidecarKey)}`);
      if (!resp.ok) {
        return;
      }
      const j = await resp.json().catch((error) => {
        console.warn('parse sidecar json', error);
        return null;
      });
      const item = j?.item;
      if (item && item.result && typeof item.result === 'object') {
        const r = item.result;
        if (!notesDirty) {
          if (typeof r.listening === 'string') {
            noteInput.value = r.listening;
            storageSet(`note_${idx}`, noteInput.value.trim());
          }
          if (typeof r.translation === 'string') {
            transInput.value = r.translation;
            storageSet(`trans_${idx}`, transInput.value.trim());
          }
          if (entryEl) entryEl.dataset.dirty = '0';
          notesDirty = false;
        }

        if (typeof r.pronunciationAttempts === 'number' && Number.isFinite(r.pronunciationAttempts)) {
          const current = getPronunciationAttempts(idx);
          const remoteCount = Math.max(0, Math.floor(r.pronunciationAttempts));
          if (remoteCount > current) {
            setPronunciationAttempts(idx, remoteCount);
          }
        }

        const remoteListeningHistory = Array.isArray(r.listeningHistory) ? r.listeningHistory : [];
        const remoteTranslationHistory = Array.isArray(r.translationHistory) ? r.translationHistory : [];
        const legacyListening = (!remoteListeningHistory.length && r.listening && r.listeningFeedback)
          ? [{ input: r.listening, feedback: r.listeningFeedback, createdAt: r.savedAt || item.savedAt }]
          : [];
        const legacyTranslation = (!remoteTranslationHistory.length && r.translation && r.translationFeedback)
          ? [{ input: r.translation, feedback: r.translationFeedback, createdAt: r.savedAt || item.savedAt }]
          : [];

        const mergedListening = mergeHistoryEntries([...remoteListeningHistory, ...legacyListening], loadEvaluationHistory('listening', idx));
        if (mergedListening.length) {
          saveEvaluationHistory('listening', idx, mergedListening);
          renderEvaluationHistory('listening', idx, mergedListening);
        }

        const mergedTranslation = mergeHistoryEntries([...remoteTranslationHistory, ...legacyTranslation], loadEvaluationHistory('translation', idx));
        if (mergedTranslation.length) {
          saveEvaluationHistory('translation', idx, mergedTranslation);
          renderEvaluationHistory('translation', idx, mergedTranslation);
        }

  if (syncEl) syncEl.textContent = '';
      }
    } catch (error) {
      console.warn('fetchRemoteNotes failed', error);
      if (syncEl) syncEl.textContent = 'Ë™≠„ÅøËæº„Åø„Å´Â§±Êïó';
    } finally {
      remoteNoteLoading = false;
      notesLoaded = true;
      updateEntrySummary(idx);
    }
  }
  // localStorage for in-session persistence; server sync happens when section closes
  noteInput.addEventListener("input", () => {
    const v = noteInput.value.trim();
    storageSet(`note_${idx}`, v);
    notesDirty = true;
    if (entryEl) entryEl.dataset.dirty = '1';
    const syncEl = document.getElementById(`syncStatus_${idx}`);
    if (syncEl) syncEl.textContent = 'Êú™‰øùÂ≠ò (Èñâ„Åò„Çã„Å®‰øùÂ≠ò)';
    updateEntrySummary(idx);
  });
  transInput.addEventListener("input", () => {
    const v = transInput.value.trim();
    storageSet(`trans_${idx}`, v);
    notesDirty = true;
    if (entryEl) entryEl.dataset.dirty = '1';
    const syncEl = document.getElementById(`syncStatus_${idx}`);
    if (syncEl) syncEl.textContent = 'Êú™‰øùÂ≠ò (Èñâ„Åò„Çã„Å®‰øùÂ≠ò)';
    updateEntrySummary(idx);
  });
  const listeningBtn = document.getElementById(`note_${idx}_compare`);
  const translationBtn = document.getElementById(`trans_${idx}_compare`);
  if (listeningBtn) {
    listeningBtn.addEventListener('click', () =>
      callChatGPT({ type: 'listening', idx, inputEl: noteInput, referenceText: sentence, buttonEl: listeningBtn })
    );
  }
  if (translationBtn) {
    translationBtn.addEventListener('click', () =>
      callChatGPT({ type: 'translation', idx, inputEl: transInput, referenceText: sentence, buttonEl: translationBtn })
    );
  }

  // save note/translation pair to server sidecar for cross-device sync
  async function saveNotesToServer(sectionIdx){
    if (!notesDirty) return;
    try{
      const syncEl = document.getElementById(`syncStatus_${sectionIdx}`);
    const listening = document.getElementById(`note_${sectionIdx}_input`).value.trim();
    const translation = document.getElementById(`trans_${sectionIdx}_input`).value.trim();
    const listeningHistory = loadEvaluationHistory('listening', sectionIdx);
    const translationHistory = loadEvaluationHistory('translation', sectionIdx);
    const pronunciationAttempts = getPronunciationAttempts(sectionIdx);
      if (syncEl) syncEl.textContent = '‰øùÂ≠ò‰∏≠‚Ä¶';
      updateEntrySummary(sectionIdx);
  const pagePrefix = PAGE_PREFIX;
  const body = { key: pagePrefix + `notes_section_${sectionIdx}`, result: { listening, translation, listeningHistory, translationHistory, pronunciationAttempts, savedAt: new Date().toISOString() }, referenceText: '' };
  const resp = await authedFetch('/api/assessment', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
      if (resp && resp.ok) {
        if (syncEl) syncEl.textContent = '‰øùÂ≠òÊ∏à„Åø';
        notesDirty = false;
        if (entryEl) entryEl.dataset.dirty = '0';
        notesLoaded = true;
      } else {
        if (syncEl) syncEl.textContent = '‰øùÂ≠ò„Å´Â§±Êïó';
        console.warn('saveNotesToServer resp not ok', resp);
        notesDirty = true;
        if (entryEl) entryEl.dataset.dirty = '1';
      }
      updateEntrySummary(sectionIdx);
    }catch(e){
      console.warn('saveNotesToServer failed', e);
      const syncEl = document.getElementById(`syncStatus_${sectionIdx}`);
      if (syncEl) syncEl.textContent = '‰øùÂ≠ò„Å´Â§±Êïó';
      notesDirty = true;
      if (entryEl) entryEl.dataset.dirty = '1';
      updateEntrySummary(sectionIdx);
    }
  }
  if (primaryScriptBtn && primaryScriptContent) {
    primaryScriptBtn.addEventListener("click", () => {
      const isVisible = primaryScriptContent.style.display === "block";
      primaryScriptContent.style.display = isVisible ? "none" : "block";
      primaryScriptBtn.textContent = isVisible ? "üìú „Çπ„ÇØ„É™„Éó„Éà„ÇíË°®Á§∫" : "üìú „Çπ„ÇØ„É™„Éó„Éà„ÇíÈñâ„Åò„Çã";
    });
  }
  if (secondaryScriptBtn && secondaryScriptContent) {
    secondaryScriptBtn.addEventListener("click", () => {
      const isVisible = secondaryScriptContent.style.display === "block";
      secondaryScriptContent.style.display = isVisible ? "none" : "block";
      secondaryScriptBtn.textContent = isVisible ? "üìú „Çπ„ÇØ„É™„Éó„Éà„ÇíË°®Á§∫" : "üìú „Çπ„ÇØ„É™„Éó„Éà„ÇíÈñâ„Åò„Çã";
    });
  }

  let lastRecordedFile = null;
  const resultBox = document.getElementById(`result_${idx}`);
  const recStatus = document.getElementById(`recStatus_${idx}`);

  function disposePendingPreview() {
    if (pendingPreview) {
      pendingPreview.innerHTML = '';
      pendingPreview.style.display = 'none';
    }
    if (pendingPreviewUrl) {
      URL.revokeObjectURL(pendingPreviewUrl);
      pendingPreviewUrl = null;
    }
  }

  function deletePendingRecording() {
    disposePendingPreview();
    lastRecordedFile = null;
    if (submitBtn) submitBtn.disabled = true;
    if (recStatus) recStatus.textContent = '';
  resultBox.textContent = 'Èå≤Èü≥„Éó„É¨„Éì„É•„Éº„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü„ÄÇ';
    if (recToggleBtn) {
      recToggleBtn.dataset.state = 'idle';
      recToggleBtn.textContent = 'üéôÔ∏è Èå≤Èü≥ÈñãÂßã';
      recToggleBtn.classList.remove('recording');
    }
    updateEntrySummary(idx);
  }

  function showPendingPreview(file, url) {
    if (!pendingPreview) {
      URL.revokeObjectURL(url);
      return;
    }
    disposePendingPreview();
    pendingPreview.innerHTML = `
      <div class="pending-preview-header">Èå≤Èü≥„Éó„É¨„Éì„É•„Éº</div>
      <div class="pending-preview-row">
        <audio controls src="${url}"></audio>
        <button type="button" class="pending-preview-delete">„Éó„É¨„Éì„É•„ÉºÂâäÈô§</button>
      </div>
    `;
    pendingPreview.style.display = 'block';
    pendingPreviewUrl = url;
    const deleteBtn = pendingPreview.querySelector('.pending-preview-delete');
    if (deleteBtn) deleteBtn.addEventListener('click', deletePendingRecording);
  }
  // Áô∫Èü≥Ë©ï‰æ°: Èå≤Èü≥ or „Éï„Ç°„Ç§„É´ÈÅ∏Êäû -> S3„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ -> Azure Ë©ï‰æ° -> „Çµ„Ç§„Éâ„Ç´„Éº‰øùÂ≠ò -> Ë°®Á§∫
  const API_UPLOAD = '/api/upload';
  const API_ASSESS = '/api/azure-assess';
  const API_ASSESS_SAVE = '/api/assessment';

  async function fetchAssessmentsForSection(force = false) {
    if (assessmentLoading) return;
    if (assessmentsLoaded && !force) return;
    assessmentLoading = true;
    const prefix = PAGE_PREFIX + `section_${idx}/`;
    try {
  const upl = await authedFetch('/api/upload?prefix=' + encodeURIComponent(prefix));
      if (!upl.ok) return;
      const ju = await upl.json().catch(() => null);
      if (!ju || !Array.isArray(ju.items)) return;
      const collected = [];
      for (const it of ju.items) {
        const key = it.key;
        if (!key) continue;
        try {
          let fileUrl = it.presignedUrl || it.url || null;
          if (!fileUrl) {
            const info = await authedFetch('/api/upload?key=' + encodeURIComponent(key));
            if (info.ok) {
              const infoJson = await info.json().catch(() => null);
              fileUrl = infoJson?.item?.presignedUrl || infoJson?.item?.url || fileUrl;
            }
          }
          addRecordingCard(idx, { key, url: fileUrl, fileName: key.split('/').pop(), size: it.size || 0, lastModified: it.lastModified || it.LastModified });
          const assessResp = await authedFetch('/api/assessment?key=' + encodeURIComponent(key + '.assessment.json'));
          if (!assessResp.ok) continue;
          const detail = await assessResp.json().catch(() => null);
          const payload = detail?.item;
          const result = payload?.result || null;
          if (!result) continue;
          let ts = null;
          if (payload && payload.savedAt) ts = Date.parse(payload.savedAt);
          else if (it.lastModified) ts = (new Date(it.lastModified)).getTime();
          else ts = Date.now();
          collected.push({ key, result, ts });
          const savedAt = payload?.savedAt || payload?.result?.savedAt || it.lastModified || it.LastModified;
          markCardAssessed(idx, key, result, savedAt);
        } catch (error) {
          console.warn('fetchAssessmentsForSection item failed', error);
        }
      }
      if (collected.length) {
        const latest = collected.sort((a, b) => (b.ts || 0) - (a.ts || 0))[0];
        if (latest) {
          displayResults(JSON.stringify(latest.result), idx);
        }
        const assessedTotal = collected.length;
        const currentAttempts = getPronunciationAttempts(idx);
        if (assessedTotal > currentAttempts) {
          setPronunciationAttempts(idx, assessedTotal);
        }
      }
    } catch (error) {
      console.warn('fetchAssessmentsForSection failed', error);
    } finally {
      assessmentLoading = false;
      assessmentsLoaded = true;
      updateEntrySummary(idx);
    }
  }

  // no file input: only recorded files are supported

  // recorder per-section (uses AudioWorklet if available)
  let _recorder = null; // storing state per section in closure
  async function startRecordingForSection(){
    if (recToggleBtn) {
      recToggleBtn.disabled = true;
    }
    if (submitBtn) submitBtn.disabled = true;
    disposePendingPreview();
    lastRecordedFile = null;
    if (recStatus) recStatus.textContent = '';
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const ac = new (window.AudioContext||window.webkitAudioContext)({ sampleRate: 16000 });
      try { if (ac.state === 'suspended') await ac.resume(); } catch {}
      await ac.audioWorklet.addModule('./audio-recording/audio-processor.js');
      const src = ac.createMediaStreamSource(stream);
      const node = new AudioWorkletNode(ac, 'audio-processor');
      const mute = ac.createGain(); mute.gain.value = 0;
      const chunks = [];
      node.port.onmessage = ev => chunks.push(new Float32Array(ev.data));
      src.connect(node); node.connect(mute).connect(ac.destination);
  _recorder = { ac, stream, node, mute, chunks, startedAt: performance.now(), timerId: null };
      // start timer display
      try{
        const timerEl = document.getElementById(`recTimer_${idx}`);
        const start = performance.now();
        _recorder.timerId = setInterval(()=>{
          const s = Math.floor((performance.now()-start)/1000);
          const mm = String(Math.floor(s/60)).padStart(2,'0');
          const ss = String(s%60).padStart(2,'0');
          if (timerEl) timerEl.textContent = `${mm}:${ss}`;
        }, 250);
      }catch(e){}
      if (recStatus) recStatus.textContent = 'Èå≤Èü≥‰∏≠';
      if (recToggleBtn) {
        recToggleBtn.dataset.state = 'recording';
        recToggleBtn.textContent = '‚èπÔ∏è Èå≤Èü≥ÂÅúÊ≠¢';
        recToggleBtn.classList.add('recording');
      }
      if (resultBox) resultBox.textContent = '';
    } catch(e){
      if (resultBox) resultBox.textContent = 'Èå≤Èü≥ÈñãÂßãÂ§±Êïó: '+e.message;
      _recorder = null;
      if (recToggleBtn) {
        recToggleBtn.dataset.state = 'idle';
        recToggleBtn.textContent = 'üéôÔ∏è Èå≤Èü≥ÈñãÂßã';
        recToggleBtn.classList.remove('recording');
      }
    } finally {
      if (recToggleBtn) recToggleBtn.disabled = false;
    }
  }

  async function stopRecordingForSection(){
    if (!_recorder) return;
    const recorderRef = _recorder;
    if (recToggleBtn) recToggleBtn.disabled = true;
    try {
      const { stream, node, mute, chunks } = recorderRef;
      try { node && node.disconnect(); } catch {}
      try { mute && mute.disconnect(); } catch {}
      try { stream && stream.getTracks().forEach(t=>t.stop()); } catch {}
      const total = chunks.reduce((s,a)=> s + a.length, 0);
      const buf = new Float32Array(total);
      let off = 0; for (const a of chunks){ buf.set(a, off); off += a.length; }
      // resample if necessary (recorderRef.ac.sampleRate -> 16000 assumed)
      const effective = recorderRef.ac.sampleRate || 16000;
      let out = buf;
      if (Math.abs(effective - 16000) > 1) out = resampleLinear(buf, effective, 16000);
      const wav = encodeWavFromFloat32(out, 16000);
      const blob = new Blob([wav], { type: 'audio/wav' });
      // attach blob to file input (so UI still uses fileInput.files if needed)
      const file = new File([blob], `rec_${Date.now()}.wav`, { type: 'audio/wav' });
      lastRecordedFile = file;
      const previewUrl = URL.createObjectURL(blob);
      showPendingPreview(file, previewUrl);
      if (resultBox) resultBox.textContent = '';
      if (recStatus) recStatus.textContent = 'Èå≤Èü≥ÂÆå‰∫Ü';
      // stop timer and enable submit
    try{ if (recorderRef.timerId) clearInterval(recorderRef.timerId); const tEl = document.getElementById(`recTimer_${idx}`); if (tEl) tEl.textContent = ''; }catch(e){}
    const limitReached = isPronunciationLimitReached(idx);
    if (submitBtn) submitBtn.disabled = limitReached;
    if (limitReached && recStatus) {
      recStatus.textContent = `Áô∫Èü≥Ë©ï‰æ°„ÅØ1„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Å§„Åç${PRONUNCIATION_EVAL_LIMIT}Âõû„Åæ„Åß„Åß„Åô„ÄÇ`;
    }
    } catch(e){
      resultBox.textContent = 'Èå≤Èü≥ÂÅúÊ≠¢„Ç®„É©„Éº: '+e.message;
    } finally {
      try { await recorderRef.ac.close(); } catch {}
      _recorder = null;
      if (recToggleBtn) {
        recToggleBtn.disabled = false;
        recToggleBtn.dataset.state = 'idle';
        recToggleBtn.textContent = 'üéôÔ∏è Èå≤Èü≥ÈñãÂßã';
        recToggleBtn.classList.remove('recording');
      }
    }
  }

  if (recToggleBtn) {
    let toggleBusy = false;
  recToggleBtn.dataset.state = 'idle';
  recToggleBtn.classList.remove('recording');
  recToggleBtn.textContent = 'üéôÔ∏è Èå≤Èü≥ÈñãÂßã';
    recToggleBtn.addEventListener('click', async () => {
      if (toggleBusy) return;
      toggleBusy = true;
      try {
        if (_recorder) {
          await stopRecordingForSection();
        } else {
          await startRecordingForSection();
        }
      } finally {
        toggleBusy = false;
      }
    });
  }
  // move the submit button into the same row as the recording controls for better UX
  try{
    if (recToggleBtn && submitBtn && recToggleBtn.parentNode && !recToggleBtn.parentNode.contains(submitBtn)){
      submitBtn.style.marginLeft = '8px';
      recToggleBtn.parentNode.appendChild(submitBtn);
    }
  }catch(e){}

  // helper: encode/resample functions (from integrated file)
  function resampleLinear(data, src, dst){ if (src === dst) return data; const ratio = src / dst, N = Math.round(data.length / ratio); const out = new Float32Array(N); for (let i=0;i<N;i++){ const p = i * ratio, i0 = Math.floor(p), i1 = Math.min(i0+1, data.length-1), t = p - i0; out[i] = data[i0]*(1-t) + data[i1]*t; } return out; }
  function encodeWavFromFloat32(ch, sr){ const len = ch.length, buf = new ArrayBuffer(44 + len*2), v = new DataView(buf); const w = (s,o)=>{ for(let i=0;i<s.length;i++) v.setUint8(o+i,s.charCodeAt(i)); }; let p=0; w('RIFF',p); p+=4; v.setUint32(p,36+len*2,true); p+=4; w('WAVE',p); p+=4; w('fmt ',p); p+=4; v.setUint32(p,16,true); p+=4; v.setUint16(p,1,true); p+=2; v.setUint16(p,1,true); p+=2; v.setUint32(p,sr,true); p+=4; v.setUint32(p,sr*2,true); p+=4; v.setUint16(p,2,true); p+=2; v.setUint16(p,16,true); p+=2; w('data',p); p+=4; v.setUint32(p,len*2,true); p+=4; for(let i=0;i<len;i++){ const s=Math.max(-1,Math.min(1,ch[i])); v.setInt16(p, s<0? s*0x8000 : s*0x7FFF, true); p+=2; } return buf; }
  function fmtBytes(b){ if (!b) return ''; if (b<1024) return b+'B'; if (b<1024*1024) return (b/1024).toFixed(1)+'KB'; return (b/1024/1024).toFixed(2)+'MB'; }

  // upload blob/file to /api/upload with prefix per section
  async function uploadFileAndAssess(fileBlob){
    resultBox.textContent = '„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠...';
    const fd = new FormData();
    fd.append('file', new File([fileBlob], fileBlob.name || `rec_${Date.now()}.wav`, { type: fileBlob.type || 'audio/wav' }));
    const prefix = PAGE_PREFIX + `section_${idx}/`;
    fd.append('prefix', prefix);
    let uploadResp;
    try {
      // disable submit during upload/assess
      if (submitBtn) submitBtn.disabled = true;
  uploadResp = await authedFetch(API_UPLOAD, { method:'POST', body: fd });
      if (!uploadResp.ok) {
        let detail = '';
        try {
          const errText = await uploadResp.text();
          if (errText) {
            try {
              const parsed = JSON.parse(errText);
              detail = parsed.detail || parsed.error || errText;
            } catch {
              detail = errText;
            }
          }
        } catch {}
        const message = detail ? `upload failed ${uploadResp.status}: ${detail}` : `upload failed ${uploadResp.status}`;
        throw new Error(message);
      }
      const upj = await uploadResp.json();
      const audioUrl = upj.presignedUrl || upj.url;
      const s3Key = upj.key;
      // add recording card to the UI for this section
  const nowIso = new Date().toISOString();
  try { addRecordingCard(idx, { key: s3Key, url: audioUrl, fileName: fileBlob.name || ('rec_'+Date.now()+'.wav'), size: fileBlob.size || 0, lastModified: nowIso }); } catch(e){ console.warn('addRecordingCard failed', e); }
  resultBox.textContent = '„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆå‰∫Ü„ÄÇË©ï‰æ°‰∏≠‚Ä¶';
      // call azure-assess
    const referenceText = sentence;
  const assessResp = await authedFetch(API_ASSESS, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ audioUrl, referenceText, language: 'en-US' }) });
      if (!assessResp.ok) { const t = await assessResp.text(); throw new Error('azure-assess failed: '+assessResp.status+' '+t); }
      const assessJson = await assessResp.json();
      // save assessment sidecar: key should be s3Key
  const saveResp = await authedFetch(API_ASSESS_SAVE, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ key: s3Key, result: assessJson, referenceText }) });
      if (!saveResp.ok) { const t = await saveResp.text(); throw new Error('save assessment failed: '+saveResp.status+' '+t); }
      resultBox.textContent = 'Ë©ï‰æ°ÂÆå‰∫Ü„Éª‰øùÂ≠òÊ∏à„Åø';
      // render results
    // update card with assessment marker and also render main area
  try { markCardAssessed(idx, s3Key, assessJson, nowIso); } catch(e){}
    displayResults(JSON.stringify(assessJson.result || assessJson?.result || assessJson), idx);
      const attempts = incrementPronunciationAttempts(idx);
      try {
        const listeningVal = document.getElementById(`note_${idx}_input`)?.value.trim() || '';
        const translationVal = document.getElementById(`trans_${idx}_input`)?.value.trim() || '';
        const listeningHistory = loadEvaluationHistory('listening', idx);
        const translationHistory = loadEvaluationHistory('translation', idx);
        const pageKeyPrefix = PAGE_PREFIX || computePagePrefix();
        authedFetch('/api/assessment', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            key: pageKeyPrefix + `notes_section_${idx}`,
            result: {
              listening: listeningVal,
              translation: translationVal,
              listeningHistory,
              translationHistory,
              pronunciationAttempts: attempts,
              savedAt: new Date().toISOString()
            },
            referenceText: ''
          })
        }).catch(err => console.warn('persist pronunciation attempts failed', err));
      } catch (metaErr) {
        console.warn('collect pronunciation metadata failed', metaErr);
      }
      disposePendingPreview();
      lastRecordedFile = null;
      if (recStatus) recStatus.textContent = '„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÊ∏à„Åø (Èå≤Èü≥‰∏ÄË¶ß„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ)';
    } catch(e){
      resultBox.textContent = '„Ç®„É©„Éº: '+e.message;
    } finally {
      const limitReached = isPronunciationLimitReached(idx);
      if (submitBtn) submitBtn.disabled = limitReached || !lastRecordedFile;
      if (limitReached && recStatus) {
        recStatus.textContent = `Áô∫Èü≥Ë©ï‰æ°„ÅØ1„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Å§„Åç${PRONUNCIATION_EVAL_LIMIT}Âõû„Åæ„Åß„Åß„Åô„ÄÇ`;
      }
    }
    updateEntrySummary(idx);
  }

  // submit handler (file input must contain .wav or recording filled into fileInput)
  if (submitBtn) submitBtn.onclick = async () => {
    resultBox.textContent = '';
    if (!lastRecordedFile) { resultBox.textContent = 'Èå≤Èü≥„ÇíË°å„Å£„Å¶„Åã„Çâ„ÄåÁô∫Èü≥Ë©ï‰æ°„ÇíÂÆüË°å„Äç„ÇíÊäº„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'; return; }
    if (isPronunciationLimitReached(idx)) {
      alert(`Áô∫Èü≥Ë©ï‰æ°„ÅØ1„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Å§„Åç${PRONUNCIATION_EVAL_LIMIT}Âõû„Åæ„Åß„Åß„Åô„ÄÇ`);
      if (submitBtn) submitBtn.disabled = true;
      if (recStatus) recStatus.textContent = `Áô∫Èü≥Ë©ï‰æ°„ÅØ1„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Å§„Åç${PRONUNCIATION_EVAL_LIMIT}Âõû„Åæ„Åß„Åß„Åô„ÄÇ`;
      return;
    }
    await uploadFileAndAssess(lastRecordedFile);
  };

  if (submitBtn && isPronunciationLimitReached(idx)) {
    submitBtn.disabled = true;
    if (recStatus) recStatus.textContent = `Áô∫Èü≥Ë©ï‰æ°„ÅØ1„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Å§„Åç${PRONUNCIATION_EVAL_LIMIT}Âõû„Åæ„Åß„Åß„Åô„ÄÇ`;
  }

  // page-level word toggle removed; per-card controls are used instead
}

// ChatGPTÈÄ£Êê∫ÔºàÊó•Êú¨Ë™û„Éó„É≠„É≥„Éó„ÉàÔºâ
async function callChatGPT({ type, idx, inputEl, referenceText, buttonEl }) {
  const isTranslation = type === 'translation';
  const textValue = inputEl?.value ?? '';
  const userText = String(textValue).trim();
  if (!userText) {
    if (inputEl) inputEl.focus();
    return;
  }

  if (!isTranslation) {
    const existing = getEvaluationHistoryCount('listening', idx);
    if (existing >= LISTENING_EVAL_LIMIT) {
      alert(`ËÅû„ÅçÂèñ„ÇäË©ï‰æ°„ÅØ1„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Å§„Åç${LISTENING_EVAL_LIMIT}Âõû„Åæ„Åß„Åß„Åô„ÄÇ`);
      return;
    }
  } else {
    const existing = getEvaluationHistoryCount('translation', idx);
    if (existing >= TRANSLATION_EVAL_LIMIT) {
      alert(`ÁøªË®≥Ë©ï‰æ°„ÅØ1„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Å§„Åç${TRANSLATION_EVAL_LIMIT}Âõû„Åæ„Åß„Åß„Åô„ÄÇ`);
      return;
    }
  }

  const prompt = isTranslation
    ? { system: "‰ª•‰∏ã„ÅØÁøªË®≥Ë©ï‰æ°„Åß„Åô„ÄÇ", template: "Â≠¶ÁøíËÄÖ„ÅÆË®≥: {{student}}\nÂéüÊñá: {{reference}}\nË™§Ë®≥„ÇÑ‰∏çË∂≥„ÄÅËâØ„ÅÑÁÇπ„ÇíÊó•Êú¨Ë™û„ÅßÁ∞°ÊΩî„Å´ÊåáÊëò„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ" }
    : {
        system: "„ÅÇ„Å™„Åü„ÅØËã±Ë™û„É™„Çπ„Éã„É≥„Ç∞„ÇíÊåáÂ∞é„Åô„ÇãË¨õÂ∏´„Åß„Åô„ÄÇÂ≠¶ÁøíËÄÖ„ÅåËÅû„ÅçÂèñ„Å£„ÅüËã±Êñá„Å®ÂÖ¨Âºè„Çπ„ÇØ„É™„Éó„Éà„Çí‰∏ÅÂØß„Å´ÊØîËºÉ„Åó„ÄÅ„Å©„ÅÆË™û„ÅåÊ≠£„Åó„Åè„ÄÅ„Å©„Åì„Å´Êäú„Åë„ÇÑË™§„Çä„Åå„ÅÇ„Çã„Åã„ÇíÂÖ∑‰ΩìÁöÑ„Å´ÊåáÊëò„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÊõñÊòß„Å™Ë©ï‰æ°„ÇÑ„ÄéÊ≠£„Åó„ÅÑ„Åß„Åô„Äè„Å†„Åë„ÅßÊ∏à„Åæ„Åõ„Åö„ÄÅÊîπÂñÑÁÇπ„ÉªÊ¨°„ÅÆÁ∑¥Áøí„Ç¢„Ç§„Éá„Ç¢„ÇÇÂøÖ„ÅöÁõõ„ÇäËæº„Åø„Åæ„Åô„ÄÇÊó•Êú¨Ë™û„ÅßÂàÜ„Åã„Çä„ÇÑ„Åô„Åè„ÄÅËÇØÂÆöÁöÑ„Å™„Éà„Éº„É≥„Çí‰øù„Å°„Å™„Åå„Çâ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„ÇíËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        template: "Â≠¶ÁøíËÄÖ„ÅåËÅû„ÅçÂèñ„Å£„Å¶ÂÖ•Âäõ„Åó„ÅüËã±Êñá:\n{{student}}\n\nÂÖ¨Âºè„ÅÆÊ≠£„Åó„ÅÑ„Çπ„ÇØ„É™„Éó„Éà:\n{{reference}}\n\n‰ª•‰∏ã„ÅÆÂΩ¢Âºè„ÅßÊó•Êú¨Ë™û„ÅßÂõûÁ≠î„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n1. ÂÖ®‰ΩìË©ï‰æ°ÔºàÊ≠£Á¢∫„Åï„Çí‰∏ÄË®Ä„ÅßÔºâ\n2. ËâØ„Åã„Å£„ÅüÁÇπÔºà„ÅÇ„Çå„Å∞ÁÆáÊù°Êõ∏„ÅçÔºâ\n3. ÊîπÂñÑÁÇπÔºà‰∏çË∂≥„ÉªË™§„Çä„ÉªÈ†ÜÂ∫èÈÅï„ÅÑ„Å™„Å©ÂÖ∑‰ΩìÁöÑ„Å´Ôºâ\n4. Ê¨°„ÅÆÁ∑¥Áøí„Ç¢„Éâ„Éê„Ç§„ÇπÔºà1„Å§Ôºâ"
      };

  const originalLabel = buttonEl?.textContent;
  if (buttonEl) {
    buttonEl.disabled = true;
    buttonEl.textContent = 'Ë©ï‰æ°‰∏≠‚Ä¶';
  }

  try {
    const systemPrompt = prompt.system;
    const userPrompt = prompt.template.replace("{{student}}", userText).replace("{{reference}}", referenceText);
    const body = { model: 'gpt-4', messages: [ { role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt } ] };
    const res = await authedFetch('/api/chat', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
    if (!res.ok) throw new Error(`Error: ${res.status} ${res.statusText}`);
    const data = await res.json();
    const feedback = data.choices?.[0]?.message?.content || '‚ö†Ô∏è ÂøúÁ≠î„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ';

  appendEvaluationHistory(isTranslation ? 'translation' : 'listening', idx, userText, feedback);

  const legacyKey = isTranslation ? `chatResponse_translation_${idx}` : `chatResponse_listening_${idx}`;
  storageRemove(legacyKey);

    if (inputEl) {
      inputEl.value = '';
      const storageKey = isTranslation ? `trans_${idx}` : `note_${idx}`;
      storageRemove(storageKey);
    }

    const listening = document.getElementById(`note_${idx}_input`)?.value.trim() || '';
    const translation = document.getElementById(`trans_${idx}_input`)?.value.trim() || '';
    const listeningHistory = loadEvaluationHistory('listening', idx);
    const translationHistory = loadEvaluationHistory('translation', idx);
    const pronunciationAttempts = getPronunciationAttempts(idx);

    const pageKeyPrefix = PAGE_PREFIX || computePagePrefix();
    authedFetch('/api/assessment', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        key: pageKeyPrefix + `notes_section_${idx}`,
        result: {
          listening,
          translation,
          listeningHistory,
          translationHistory,
          pronunciationAttempts,
          savedAt: new Date().toISOString()
        },
        referenceText: ''
      })
    }).catch(e => console.warn('persist chat feedback failed', e));

    const entryEl = document.querySelector(`.entry[data-section="${idx}"]`);
    if (entryEl) entryEl.dataset.dirty = '0';
    const syncEl = document.getElementById(`syncStatus_${idx}`);
    if (syncEl) syncEl.textContent = '‰øùÂ≠òÊ∏à„Åø';
  } catch (e) {
    console.warn('callChatGPT failed', e);
    alert(`Ë©ï‰æ°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${e.message}`);
  } finally {
    if (buttonEl) {
      buttonEl.disabled = false;
      buttonEl.textContent = originalLabel || (isTranslation ? 'ÁøªË®≥Ë©ï‰æ°' : '„É™„Çπ„Éã„É≥„Ç∞Ë©ï‰æ°');
    }
    updateEntrySummary(idx);
  }
}

function displayResults(jsonString, idx) {
  // make function tolerant to multiple Azure response shapes
  let data;
  try { data = (typeof jsonString === 'string') ? JSON.parse(jsonString) : jsonString; } catch (e) { data = jsonString; }

  // normalize: try a few common nesting patterns where the actual NBest may live
  const pickNested = (obj) => {
    if (!obj || typeof obj !== 'object') return null;
    if (Array.isArray(obj.NBest) && obj.NBest.length) return obj;
    if (obj.result && Array.isArray(obj.result.NBest) && obj.result.NBest.length) return obj.result;
    if (obj.result && obj.result.result && Array.isArray(obj.result.result.NBest) && obj.result.result.NBest.length) return obj.result.result;
    // sometimes the payload itself is the NBest entry
    if (Array.isArray(obj) && obj.length && obj[0].Words) return { NBest: obj };
    return obj;
  };

  const normalized = pickNested(data) || data;
  // prefer first NBest entry; if missing, fallback to 'result' object
  const nb = (Array.isArray(normalized.NBest) && normalized.NBest[0]) || normalized.NBest || normalized.result || normalized;

  // PronunciationAssessment may be nested or flattened
  const pa = nb.PronunciationAssessment || nb;
  const score = pa.PronScore ?? pa.PronunciationScore ?? pa.Pron ?? pa.PronunciationScore ?? null;
  const accuracy = pa.AccuracyScore ?? pa.AccScore ?? nb.AccuracyScore ?? nb.AccScore ?? null;
  const fluency = pa.FluencyScore ?? pa.FluScore ?? nb.FluencyScore ?? nb.FluScore ?? null;
  const completeness = pa.CompletenessScore ?? pa.CompScore ?? nb.CompletenessScore ?? nb.CompScore ?? null;
  const words = nb.Words || pa.Words || [];

  // main numeric score and subscores intentionally omitted ‚Äî per-card UI shows word-level details
  const scoreEl = document.getElementById(`scoreBlock_${idx}`);
  if (scoreEl) scoreEl.innerHTML = '';
  // also hide/clear the page-level words block to avoid duplicate information
  const wordsMain = document.getElementById(`wordsBlock_${idx}`);
  if (wordsMain) { wordsMain.style.display = 'none'; const tb = wordsMain.querySelector('tbody'); if (tb) tb.innerHTML = ''; }
  // done ‚Äî per-card rendering handled elsewhere
  return;
  // page-level words display intentionally suppressed; details shown on recording cards
}

// ===== persistence: load saved recordings & assessments for this page =====
// small utility: format bytes -> human readable
function fmtBytes(b){
  if (!b && b !== 0) return '';
  if (b < 1024) return b + 'B';
  if (b < 1024 * 1024) return (b / 1024).toFixed(1) + 'KB';
  return (b / 1024 / 1024).toFixed(2) + 'MB';
}

function formatRelativeTime(ts){
  if (!ts) return '';
  const date = (ts instanceof Date) ? ts : new Date(ts);
  if (Number.isNaN(date.getTime())) return '';
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const minutes = Math.floor(diffMs / 60000);
  const hours = Math.floor(diffMs / 3600000);
  const days = Math.floor(diffMs / 86400000);
  if (diffMs < 0) return 'Êú™Êù•„ÅÆÈå≤Èü≥';
  if (minutes < 1) return '„Åü„Å£„Åü‰ªä';
  if (minutes < 60) return `${minutes}ÂàÜÂâç`;
  if (hours < 24 && now.toDateString() === date.toDateString()) return `${hours}ÊôÇÈñìÂâç`;
  if (days === 1) return '1Êó•Ââç';
  if (days < 7) return `${days}Êó•Ââç`;
  return date.toLocaleString();
}

function setCardTimestamp(card, ts){
  if (!card) return;
  const date = ts ? new Date(ts) : null;
  if (!date || Number.isNaN(date.getTime())) return;
  card.dataset.lastModified = date.toISOString();
  const tsEl = card.querySelector('.rec-timestamp');
  if (tsEl) tsEl.textContent = formatRelativeTime(date);
}

function reorderRecordingList(listEl){
  if (!listEl) return;
  const cards = Array.from(listEl.children);
  cards.sort((a, b) => {
    const ta = new Date(a.dataset?.lastModified || 0).getTime();
    const tb = new Date(b.dataset?.lastModified || 0).getTime();
    return tb - ta;
  });
  cards.forEach(card => listEl.appendChild(card));
}
// create a small card element in the per-section recList to represent one recording
function addRecordingCard(sectionIdx, meta){
  try{
    const listEl = document.getElementById(`recList_${sectionIdx}`);
    if (!listEl) return;
    // avoid duplicate card for same key
    if (meta && meta.key){
      if (listEl.querySelector(`[data-s3key="${meta.key}"]`)) return;
    }
    const wrapper = document.createElement('div');
    wrapper.className = 'rec-card';
    if (meta && meta.key) wrapper.setAttribute('data-s3key', meta.key);
  if (meta && meta.lastModified) wrapper.dataset.lastModified = String(meta.lastModified);

    // left: circular score canvas
  const left = document.createElement('div'); left.className = 'left';
  left.style = 'display:flex;align-items:center;gap:10px;';
  const canvas = document.createElement('canvas'); canvas.width = 80; canvas.height = 80; canvas.style.width = '72px'; canvas.style.height = '72px';
  const toggleWordsBtn = document.createElement('button');
  toggleWordsBtn.textContent = 'ÂçòË™û';
  toggleWordsBtn.className = 'toggle-words-btn';
  toggleWordsBtn.disabled = true;
  toggleWordsBtn.style = 'min-width:72px;';
  left.appendChild(canvas);
  left.appendChild(toggleWordsBtn);

    // right: inline row with audio + controls (donut, audio, buttons on one line)
    const right = document.createElement('div'); right.className = 'right';
    const inlineRow = document.createElement('div'); inlineRow.style = 'display:flex;align-items:center;gap:8px;';
    // audio element (shortened to fit)
    let a = null;
    if (meta.url){
      a = document.createElement('audio'); a.controls = true; a.src = meta.url;
      // allow audio control to flex/grow to fill remaining horizontal space
      a.style.flex = '1 1 auto'; a.style.width = 'auto'; a.style.maxWidth = 'none'; a.style.minWidth = '140px'; a.style.display = 'block';
    } else {
      a = document.createElement('div'); a.textContent = 'ÔºàÈü≥Â£∞„Å™„ÅóÔºâ'; a.style.color = '#666';
    }
    const audioWrap = document.createElement('div');
    audioWrap.style = 'display:flex;align-items:center;gap:4px;flex:1 1 auto;min-width:0;';
    audioWrap.appendChild(a);
    const timestampEl = document.createElement('span');
    timestampEl.className = 'rec-timestamp';
    timestampEl.style = 'font-size:0.85rem;color:#6b7280;white-space:nowrap;flex:0 0 auto;';
    audioWrap.appendChild(timestampEl);
  const controls = document.createElement('div'); controls.style = 'display:flex;gap:8px;align-items:center;flex:0 0 auto;';
  const delBtn = document.createElement('button'); delBtn.textContent = 'Èå≤Èü≥ÂâäÈô§'; delBtn.style.background = '#e53e3e';
    controls.appendChild(delBtn);
    inlineRow.appendChild(audioWrap); inlineRow.appendChild(controls);
    right.appendChild(inlineRow);

  const summary = document.createElement('div'); summary.className = 'rec-summary'; summary.style = 'margin-top:6px;color:#333;font-size:0.95rem;'; summary.innerHTML = '';
  right.appendChild(summary);

    // word-level table (hidden initially)
    const wordsContainer = document.createElement('div'); wordsContainer.className = 'word-table'; wordsContainer.style.display = 'none';
    wordsContainer.innerHTML = `<table style="width:100%;border-collapse:collapse;"><thead><tr><th>ÂçòË™û</th><th>„Çπ„Ç≥„Ç¢</th><th>Âà§ÂÆö</th></tr></thead><tbody></tbody></table>`;
    right.appendChild(wordsContainer);

    // wire up buttons
    delBtn.onclick = async ()=>{
      if (!meta.key) { wrapper.remove(); updateEntrySummary(sectionIdx); return; }
    if (!confirm('„Åì„ÅÆÈå≤Èü≥„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) return;
  const resp = await authedFetch('/api/upload?key=' + encodeURIComponent(meta.key), { method: 'DELETE' });
    if (resp.ok) { wrapper.remove(); updateEntrySummary(sectionIdx); } else { alert('Èå≤Èü≥ÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'); }
    };
    toggleWordsBtn.onclick = ()=>{
      try{
        const wc = wrapper.querySelector('.word-table');
        if (!wc) return;
        if (wc.style.display === 'none' || wc.style.display === ''){ wc.style.display = 'block'; toggleWordsBtn.textContent = 'Èö†„Åô'; }
        else { wc.style.display = 'none'; toggleWordsBtn.textContent = 'ÂçòË™û'; }
      }catch(e){ console.warn('toggleWordsBtn', e); }
    };

    wrapper.appendChild(left);
    wrapper.appendChild(right);
    listEl.appendChild(wrapper);
    const tsIso = (() => {
      if (meta && meta.lastModified) {
        const dt = new Date(meta.lastModified);
        if (!Number.isNaN(dt.getTime())) return dt.toISOString();
      }
      return new Date().toISOString();
    })();
    setCardTimestamp(wrapper, tsIso);
    reorderRecordingList(listEl);
    updateEntrySummary(sectionIdx);
    // ensure only our donut canvas remains in the card (remove stray canvases)
    canvas.classList.add('rec-donut');
    const allCanvases = wrapper.querySelectorAll('canvas');
    allCanvases.forEach(c => { if (!c.classList.contains('rec-donut')) c.remove(); });
    // draw initial placeholder donut
    drawDonutOnCanvas(canvas, null);
  }catch(e){ console.warn('addRecordingCard error', e); }
}

// mark an existing card as assessed and attach short summary (and store full result on element)
function markCardAssessed(sectionIdx, s3Key, assessJson, savedAt){
  try{
    const listEl = document.getElementById(`recList_${sectionIdx}`); if (!listEl) return;
    const card = listEl.querySelector(`[data-s3key="${s3Key}"]`);
    if (!card) return;
    card.dataset.assessed = 'true';
    const summary = card.querySelector('div');
    // try to pull a numeric score
  const nb = (assessJson && (assessJson.result || assessJson))?.result || assessJson?.result || assessJson;
    // find first score value tolerant
    let score = null;
    try{ const s = (assessJson?.result?.NBest?.[0]) || (assessJson?.NBest?.[0]) || assessJson; score = s?.PronunciationAssessment?.PronScore ?? s?.PronScore ?? s?.PronunciationScore ?? s?.Score ?? null; }catch(e){}
    const summaryEl = card.querySelector('.rec-summary') || card.querySelector('.right > .rec-summary') || card.lastElementChild;
    if (summaryEl) summaryEl.innerHTML = '';
    card.__assessment = assessJson;
    // draw donut on card canvas
    try{
      const canvas = card.querySelector('canvas');
      if (canvas){ drawDonutOnCanvas(canvas, Number(score)); }
    }catch(e){}
    // populate word table if available; enable the toggle button when words exist
    try{
      const root = pickNBestRoot(assessJson) || pickNBestRoot(assessJson?.result) || pickNBestRoot(assessJson?.result?.result) || null;
      let words = [];
      if (root && Array.isArray(root.NBest) && root.NBest[0]){
        words = root.NBest[0].Words || root.NBest[0].PronunciationAssessment?.Words || [];
      } else if (assessJson && Array.isArray(assessJson.NBest) && assessJson.NBest[0]){
        words = assessJson.NBest[0].Words || assessJson.NBest[0].PronunciationAssessment?.Words || [];
      } else if (assessJson && assessJson.Words && Array.isArray(assessJson.Words)){
        words = assessJson.Words;
      }
    const wordsTable = card.querySelector('.word-table tbody');
      if (wordsTable){
        wordsTable.innerHTML = '';
        for (const w of words){
          const wa = w.PronunciationAssessment || w;
          const wordText = w.Word || w.Display || w?.WordText || '';
          const acc = (wa && (wa.AccuracyScore ?? wa.AccScore ?? wa.PronunciationAssessment?.AccuracyScore)) ?? 'N/A';
          const errorType = wa?.ErrorType || wa?.PronunciationAssessment?.ErrorType || 'None';
          const label = { 'None':'‚úÖ Ê≠£„Åó„ÅèÁô∫Èü≥','Omission':'‚ö†Ô∏è ËÑ±ËêΩ','Mispronunciation':'üåÄ Ë™§„Çä','Insertion':'‚ûï ÊåøÂÖ•' }[errorType] || errorType;
          const tr = document.createElement('tr');
          tr.innerHTML = `<td style="text-align:center">${wordText}</td><td style="text-align:center"><strong>${acc}</strong></td><td style="text-align:center">${label}</td>`;
          wordsTable.appendChild(tr);
        }
        const wc = card.querySelector('.word-table');
        if (wc){
          // keep hidden by default, but enable toggle button
          wc.style.display = 'none';
          const tb = card.querySelector('.toggle-words-btn'); if (tb) { tb.disabled = false; tb.textContent = 'ÂçòË™û'; }
        }
      }
    }catch(e){ console.warn('markCardAssessed word table', e); }
    if (savedAt) setCardTimestamp(card, savedAt);
    reorderRecordingList(listEl);
    updateEntrySummary(sectionIdx);
  }catch(e){ console.warn('markCardAssessed', e); }
}

// draw donut/arc on the given canvas; if score is null, show hollow gray circle
function drawDonutOnCanvas(canvas, score){
  try{
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height; const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 6;
    ctx.clearRect(0,0,w,h);
    // background track
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.strokeStyle = '#eee'; ctx.lineWidth = 8; ctx.stroke();
    if (score === null || score === undefined || Number.isNaN(Number(score))){
      // placeholder center text
      ctx.font = '12px sans-serif'; ctx.fillStyle = '#666'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('N/A', cx, cy);
      return;
    }
    const p = Math.max(0, Math.min(1, Number(score)/100));
    const start = -0.5*Math.PI, end = start + p * Math.PI * 2;
    // gradient stroke
    const grad = ctx.createLinearGradient(0,0,w,h); grad.addColorStop(0,'#f97316'); grad.addColorStop(1,'#4caf50');
    ctx.beginPath(); ctx.arc(cx,cy,r,start,end); ctx.strokeStyle = grad; ctx.lineWidth = 8; ctx.lineCap = 'round'; ctx.stroke();
  ctx.font = 'bold 16px sans-serif'; ctx.fillStyle = '#222'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText((Number(score).toFixed(1)), cx, cy);
  }catch(e){ console.warn('drawDonutOnCanvas', e); }
}

// helper: find the NBest-containing root object for various Azure response shapes
function pickNBestRoot(obj){
  if (!obj || typeof obj !== 'object') return null;
  if (Array.isArray(obj.NBest) && obj.NBest.length) return obj;
  if (obj.result && Array.isArray(obj.result.NBest) && obj.result.NBest.length) return obj.result;
  if (obj.result && obj.result.result && Array.isArray(obj.result.result.NBest) && obj.result.result.NBest.length) return obj.result.result;
  // sometimes the payload is already the NBest array
  if (Array.isArray(obj) && obj.length && obj[0] && (obj[0].Words || obj[0].Word)) return { NBest: obj };
  // fallbacks
  if (obj.NBest && Array.isArray(obj.NBest)) return obj;
  return null;
}

const logoutBtnEl = document.getElementById('logoutBtn');
if (logoutBtnEl) {
  logoutBtnEl.addEventListener('click', (event) => {
    event.preventDefault();
    logoutUser();
  });
}

updateAuthBar();

(async function bootstrap(){
  try {
    await ensureAuthenticated();
    currentAuthUserId = authState.userId;
    PAGE_PREFIX = computePagePrefix();
    buildSections();
  } catch (e) {
    console.error('initialization failed', e);
  }
})();

</script>

<footer style="max-width: 820px; margin: 2rem auto 0 auto; padding: 1rem; text-align: center; font-size: 0.9rem; color: #6b7280; border-top: 1px solid #e5e7eb;">
  Âá∫ÂÖ∏ÔºöVoice of AmericaÔºàVOAÔºâ„Çà„ÇäÂºïÁî®
</footer>

</body>
</html>