<!-- 2025-08-10 ‰ΩúÊàê ÂêÑ„Çª„ÇØ„Ç∑„Éß„É≥„Å´Áô∫Èü≥Ë©ï‰æ°Ê©üËÉΩ„ÇíÂê´„ÇÄ -->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Ëã±Ë™û„ÅÆÁ≠ã„Éà„É¨</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* make sizing predictable and avoid horizontal overflow */
    *, *::before, *::after { box-sizing: border-box; }
    html, body { overflow-x: hidden; }
  body { font-family: sans-serif; padding: 1rem; background: #f0f2f5; max-width: none; width: 100%; margin: 0; line-height: 1.6; }
    .card { background: transparent; border: none; padding: 0; margin-bottom: 2rem; box-shadow: none; }
    .entry { border: 1px solid #ddd; border-radius: 12px; background: #fff; overflow: hidden; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05); }
  .entry summary { position: relative; list-style: none; display: flex; align-items: center; gap: 12px; flex-wrap: wrap; padding: 1rem 1.25rem; background: #f7f8fc; cursor: pointer; font-weight: 600; color: #1f2937; }
  .entry summary::before { content: '\25B6'; color: #6366f1; font-size: 0.85rem; transition: transform 0.2s ease; }
  .entry.expanded summary::before,
  .entry[open] summary::before { transform: rotate(90deg); }
    .entry summary::-webkit-details-marker { display: none; }
    .entry.expanded summary,
    .entry[open] summary { border-bottom: 1px solid #e5e7eb; background: #eef2ff; }
  .entry-title { flex: 0 0 auto; font-size: 1.05rem; }
    .entry-snippet { flex: 2 1 240px; font-size: 0.95rem; color: #6b7280; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .entry-status { position: absolute; left: 50%; transform: translateX(-50%); font-size: 0.9rem; color: #374151; white-space: nowrap; }
    .entry-body { padding: 1.25rem; background: white; }
    h1 { font-size: 2rem; color: #333; margin-bottom: 1rem; text-align: center; }
    h2 { font-size: 1.3rem; color: #555; margin-bottom: 1rem; border-bottom: 2px solid #eee; padding-bottom: 0.5rem; }
    h3 { font-size: 1.1rem; color: #666; margin-bottom: 0.8rem; }
    input[type="text"], input[type="file"], textarea { width: 100%; padding: 0.7rem; margin: 0.5rem 0; font-size: 1rem; border: 2px solid #ddd; border-radius: 6px; box-sizing: border-box; transition: border-color 0.3s; }
    button { background-color: #4caf50; color: white; border: none; padding: 0.7rem 1.2rem; font-size: 1rem; border-radius: 6px; cursor: pointer; margin: 0.3rem 0.5rem 0.3rem 0; transition: background-color 0.3s; }
    button:hover { background-color: #45a049; }
    button:disabled { background-color: #ccc; cursor: not-allowed; }
    audio { width: 100%; margin: 1rem 0; border-radius: 6px; }
    .subtitle { font-size: 1.4rem; margin-bottom: 1.5rem; }
    .status { margin-top: 0.5rem; font-size: 1rem; color: #333; }
    .collapsible { background-color: #eee; cursor: pointer; padding: 0.5rem 1rem; border: none; font-size: 0.95rem; margin-top: 0.8rem; width: 100%; border-radius: 6px; text-align: left; }
    .collapsible:hover { background-color: #ddd; }
    .script-toggle { display: inline-flex; align-items: center; gap: 0.35rem; font-weight: 600; color: #111827; background-color: #e0e7ff; border: 1px solid #c7d2fe; }
    .script-toggle:hover { background-color: #c7d2fe; }
  .content { display: none; background-color: #fafafa; padding: 1rem; border: 1px solid #ccc; margin-top: 0.5rem; border-radius: 6px; white-space: pre-wrap; }
  .pending-preview { display: none; margin-top: 0.75rem; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 8px; background: #fff; }
  .pending-preview audio { flex: 1 1 auto; width: auto; min-width: 180px; }
  .pending-preview-row { display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
  .pending-preview-header { font-weight: 600; font-size: 0.95rem; color: #1f2937; margin-bottom: 0.5rem; }
  .pending-preview button { background-color: #ef4444; }
  .pending-preview button:hover { background-color: #dc2626; }
  .evaluation-block { background: #f9fafb; border: 1px solid #d1d5db; border-radius: 10px; padding: 1rem; margin-top: 1rem; }
  .evaluation-header { display: flex; align-items: center; gap: 0.75rem; margin: 0 0 0.5rem 0; }
  .evaluation-title { margin: 0; font-size: 1.1rem; color: #374151; }
  .evaluation-header button { margin: 0; }
  .evaluation-header .eval-quota { margin-left: auto; }
  .evaluation-header .evaluation-toggle { background: #e5e7eb; color: #374151; padding: 0.35rem 0.7rem; border-radius: 6px; font-size: 0.85rem; }
  .evaluation-header .evaluation-toggle:hover { background: #d1d5db; }
  .evaluation-block.collapsed { padding-bottom: 0.75rem; }
  .evaluation-body { display: flex; flex-direction: column; gap: 0.75rem; margin-top: 0.75rem; }
  .evaluation-actions { display: flex; gap: 0.5rem; align-items: center; }
  .evaluation-actions button { margin: 0; }
  .evaluation-block.collapsed .evaluation-body { display: none; }
  .score-trend { font-size: 0.85rem; color: #2563eb; margin-left: 0.4rem; white-space: nowrap; }
  .eval-quota { font-size: 0.9rem; color: #059669; font-weight: 600; }
  .pronunciation-controls { display: flex; gap: 8px; align-items: center; margin-top: 8px; flex-wrap: wrap; }
  .pronunciation-actions { margin-left: auto; display: flex; align-items: center; gap: 8px; }
  .pronunciation-controls .rec-toggle { display: inline-flex; align-items: center; gap: 6px; padding: 0.65rem 1.1rem; background-color: #2563eb; }
  .pronunciation-controls .rec-toggle.recording { background-color: #dc2626; }
  .pronunciation-status { color: #4b5563; font-size: 0.95rem; }
  .pronunciation-timer { color: #b91c1c; font-weight: 600; }
  .evaluation-history { margin-top: 0.75rem; border-top: 1px dashed #d1d5db; padding-top: 0.75rem; display: flex; flex-direction: column; gap: 0.75rem; }
  .history-entry { background: #fff; border: 1px solid #e5e7eb; border-radius: 8px; padding: 0.75rem; display: flex; flex-direction: column; gap: 0.5rem; }
  .history-entry-header { display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: #6b7280; }
  .history-entry-header .history-score { font-weight: 600; color: #2563eb; }
  .history-entry-header .history-delete { background: #f87171; padding: 0.3rem 0.6rem; font-size: 0.8rem; margin-left: auto; }
  .history-entry-header .history-delete:hover { background: #dc2626; }
  .history-row { display: flex; gap: 0.5rem; align-items: flex-start; }
  .history-label { font-weight: 600; min-width: 3rem; color: #374151; font-size: 0.9rem; }
  .history-text { flex: 1 1 auto; white-space: pre-wrap; word-break: break-word; font-size: 0.95rem; color: #1f2937; }
  .history-empty { font-size: 0.9rem; color: #6b7280; }
    #scoreBlock { margin: 1rem 0; text-align: center; }
    #wordsBlock { margin-top: 1rem; }
    table { width: 100%; border-collapse: collapse; text-align: left; }
    th, td { border: 1px solid #ddd; padding: 0.5rem; }
    th { background: #f8f9fa; }
  /* recording card layout */
  .rec-card { display:flex; gap:12px; align-items:flex-start; background: #fff; border-radius:8px; padding:8px; width:100%; box-sizing:border-box; flex-wrap:wrap; }
  .rec-card .left { display:flex; align-items:center; justify-content:flex-start; flex:0 0 auto; gap:10px; }
  .rec-card .right { flex:1 1 auto; min-width:0; }
  .rec-card canvas { background:transparent; }
  .word-table { margin-top:8px; font-size:0.92rem; border-top:1px dashed #eee; padding-top:8px; }
  .word-table-hint { font-size:0.85rem; color: #4b5563; margin-bottom: 0.5rem; }
    @media (max-width: 768px) { body { padding: 0.5rem; } .card { padding: 1rem; } h1 { font-size: 1.5rem; } button { padding: 0.6rem 1rem; font-size: 0.9rem; } }
  </style>
</head>
<body>

<h1>Ëã±Ë™û„ÅÆÁ≠ã„Éà„É¨</h1>
<div id="sentence-sections"></div>

<script>
'use strict';
// ‰æãÊñáÔºàÈÅ©ÂÆúÂ§âÊõ¥ÂèØÔºâ
const sentences = [
  "Many iPhones and other Apple products are made in China.",
  "In recent years, Apple has expanded its manufacturing into other countries such as Vietnam and India.",
  "But not so much to the United States.",
  "That is changing.",
  "This week, Apple said that over the next 4 years it would invest $500 billion in the US with plans that include building a Texas facility to manufacture artificial intelligence servers and commit to creating 20,000 US jobs.",
  "Apple's announcement follows a meeting last week between CEO Tim Cook and President Donald Trump.",
  "The iPhone maker is among US firms recently announcing domestic investment and job creation.",
  "\"...and they're going to build here instead because they don't want to pay the tariffs.\"",
  "In a social media post on Thursday, Trump doubled the 10% universal tariff imposed on China, effective Tuesday.",
  "Observers say that Apple's move is part of its trend to diversify its supply chain and it's not related to Trump's tariffs on China.",
  "I mean, they are now in the, in, have been for some years, i.., in the process of , uh, moving production away from China anyway, uh,  pre-tariff.",
  "There's still a substantial amount in China, but, uhm.",
  "Th, there's a trend here that's clear, and I think that Apple will continue that.",
  "While much of Apple's plans had been known, the company is signaling its pro-US jobs and investment policy, a priority for the Trump administration.",
  "They're just taking the opportunity to use, ??????, the press releases to try to just get some more public exposure for a lot of things they were already spending and and obviously align well with kind of a pro, pro US policy.",
  "As part of its US investment, Apple said it would produce its advanced silicon chips in the Arizona plant of TSMC, the Taiwanese semiconductor firm.",
  "Michelle Quinn, VOA news."
];
const audioFolderName = "With $500B US investment, Apple pulling away from China, analysts say";
// Encode folder name so static hosts serve files even with spaces/symbols in path
const base = `./${encodeURIComponent(audioFolderName)}`;
const container = document.getElementById("sentence-sections");

const AUTH_STORAGE_KEY = 'ela_auth_session';
const authState = { token: null, userId: null, expiresAt: 0 };
let PAGE_PREFIX = '';
let currentAuthUserId = null;
const PASSWORD_OPTIONAL_PREFIX = 'acg2_';

function sanitizeUserIdForClient(id) {
  return String(id || '').trim().replace(/[^A-Za-z0-9._-]/g, '_');
}

function setAuthState(token, userId, expiresAt) {
  authState.token = token;
  authState.userId = userId;
  authState.expiresAt = expiresAt;
  try {
    const payload = JSON.stringify({ token, userId, expiresAt });
    localStorage.setItem(AUTH_STORAGE_KEY, payload);
  } catch (e) {
    console.warn('persist auth failed', e);
  }
  updateAuthBar();
}

function clearAuthState() {
  authState.token = null;
  authState.userId = null;
  authState.expiresAt = 0;
  try { localStorage.removeItem(AUTH_STORAGE_KEY); } catch {}
  updateAuthBar();
}

function loadAuthFromStorage() {
  try {
    const raw = localStorage.getItem(AUTH_STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') return null;
    if (!parsed.token || !parsed.userId || !parsed.expiresAt) return null;
    return parsed;
  } catch (e) {
    console.warn('load auth storage failed', e);
    return null;
  }
}

function getStorageNamespace() {
  return authState.userId ? `user_${sanitizeUserIdForClient(authState.userId)}` : 'anon';
}

function namespacedKey(base) {
  return `${getStorageNamespace()}::${base}`;
}

function storageGet(baseKey) {
  try {
    return localStorage.getItem(namespacedKey(baseKey));
  } catch (e) {
    console.warn('storageGet failed', e);
    return null;
  }
}

function storageSet(baseKey, value) {
  try {
    localStorage.setItem(namespacedKey(baseKey), value);
  } catch (e) {
    console.warn('storageSet failed', e);
  }
}

function storageRemove(baseKey) {
  try {
    localStorage.removeItem(namespacedKey(baseKey));
  } catch (e) {
    console.warn('storageRemove failed', e);
  }
}

function purgeUserScopedData(userId) {
  if (!userId) return;
  const prefix = `user_${sanitizeUserIdForClient(userId)}::`;
  try {
    const targets = [];
    for (let i = 0; i < localStorage.length; i += 1) {
      const key = localStorage.key(i);
      if (key && key.startsWith(prefix)) targets.push(key);
    }
    targets.forEach(key => {
      try { localStorage.removeItem(key); } catch (err) { console.warn('purgeUserScopedData remove failed', err); }
    });
  } catch (e) {
    console.warn('purgeUserScopedData failed', e);
  }
}

function updateAuthBar() {}

function logoutUser(options = {}) {
  const currentUser = authState.userId;
  if (currentUser) {
    purgeUserScopedData(currentUser);
  }
  clearAuthState();
  PAGE_PREFIX = '';
  currentAuthUserId = null;
  if (!options || options.silent !== true) {
    try {
      window.location.reload();
    } catch (e) {
      console.warn('reload failed after logout', e);
      promptForLogin();
    }
  }
}

const EVAL_HISTORY_LIMIT = 20;
const DEFAULT_SECTION_LIMIT = 10;
const DEFAULT_SECTION_COUNT = sentences.length;
let sectionCount = DEFAULT_SECTION_COUNT;
let sectionLimits = {
  listening: DEFAULT_SECTION_LIMIT,
  translation: DEFAULT_SECTION_LIMIT,
  pronunciation: DEFAULT_SECTION_LIMIT
};

const USAGE_TYPE_FIELD_MAP = Object.freeze({
  listening: 'listeningUsed',
  translation: 'translationUsed',
  pronunciation: 'pronunciationUsed'
});

class QuotaError extends Error {
  constructor(message, detail = null) {
    super(message);
    this.name = 'QuotaError';
    this.detail = detail;
  }
}

function computeGlobalLimitFromSections(type) {
  const perSection = sectionLimits[type];
  if (!Number.isFinite(perSection) || perSection <= 0) return Infinity;
  const count = Math.max(1, sectionCount);
  return perSection * count;
}

const quotaState = {
  initialized: false,
  loading: false,
  usage: {
    listeningUsed: 0,
    translationUsed: 0,
    pronunciationUsed: 0,
    resetAt: null,
    updatedAt: null
  },
  limits: {
    listening: computeGlobalLimitFromSections('listening'),
    translation: computeGlobalLimitFromSections('translation'),
    pronunciation: computeGlobalLimitFromSections('pronunciation')
  },
  remaining: {
    listening: Infinity,
    translation: Infinity,
    pronunciation: Infinity
  },
  sectionCount,
  storage: null,
  error: null
};

function coerceLimitValue(value, fallback) {
  if (value === undefined) {
    return fallback;
  }
  if (value === null || value === 'unlimited') {
    return Infinity;
  }
  const num = Number(value);
  if (!Number.isFinite(num) || num <= 0) return Infinity;
  return Math.floor(num);
}

function recomputeQuotaRemaining() {
  const next = { listening: Infinity, translation: Infinity, pronunciation: Infinity };
  for (const type of Object.keys(USAGE_TYPE_FIELD_MAP)) {
    const limit = quotaState.limits[type];
    const field = USAGE_TYPE_FIELD_MAP[type];
    const used = Number(quotaState.usage[field] || 0);
    if (!Number.isFinite(limit) || limit <= 0) {
      next[type] = Infinity;
    } else {
      next[type] = Math.max(0, Math.floor(limit) - Math.max(0, Math.floor(used)));
    }
  }
  quotaState.remaining = next;
}

function applyQuotaPayload(payload = {}, options = {}) {
  if (payload.sectionCount !== undefined) {
    const parsedCount = Number(payload.sectionCount);
    if (Number.isFinite(parsedCount) && parsedCount > 0) {
      sectionCount = Math.max(1, Math.floor(parsedCount));
      quotaState.sectionCount = sectionCount;
    }
  }

  if (payload.perSectionLimits && typeof payload.perSectionLimits === 'object') {
    sectionLimits = {
      listening: coerceLimitValue(payload.perSectionLimits.listening, sectionLimits.listening),
      translation: coerceLimitValue(payload.perSectionLimits.translation, sectionLimits.translation),
      pronunciation: coerceLimitValue(payload.perSectionLimits.pronunciation, sectionLimits.pronunciation)
    };
  }

  if (payload.limits && typeof payload.limits === 'object') {
    quotaState.limits = {
      listening: coerceLimitValue(payload.limits.listening, quotaState.limits.listening),
      translation: coerceLimitValue(payload.limits.translation, quotaState.limits.translation),
      pronunciation: coerceLimitValue(payload.limits.pronunciation, quotaState.limits.pronunciation)
    };
  } else if (!quotaState.initialized || payload.perSectionLimits || payload.sectionCount !== undefined) {
    quotaState.limits = {
      listening: computeGlobalLimitFromSections('listening'),
      translation: computeGlobalLimitFromSections('translation'),
      pronunciation: computeGlobalLimitFromSections('pronunciation')
    };
  }

  if (payload.usage && typeof payload.usage === 'object') {
    quotaState.usage = Object.assign({}, quotaState.usage, payload.usage);
  }

  if (payload.remaining && typeof payload.remaining === 'object') {
    quotaState.remaining = Object.assign({}, quotaState.remaining, payload.remaining);
  } else {
    recomputeQuotaRemaining();
  }

  if (payload.storage) quotaState.storage = payload.storage;
  quotaState.error = payload.error || null;
  quotaState.initialized = true;

  if (!options || options.silent !== true) {
    updateAllQuotaDisplays();
  }
}

function getGlobalQuotaRemaining(type) {
  if (!quotaState.initialized) return Infinity;
  const value = quotaState.remaining?.[type];
  if (value === null || value === undefined) return Infinity;
  if (!Number.isFinite(value)) return Infinity;
  return Math.max(0, value);
}

function isGlobalQuotaExhausted(type) {
  if (!quotaState.initialized) return false;
  const remaining = getGlobalQuotaRemaining(type);
  return Number.isFinite(remaining) && remaining <= 0;
}

async function refreshUsageState(options = {}) {
  if (quotaState.loading && options.skipIfLoading) return quotaState;
  quotaState.loading = true;
  try {
    const res = await authedFetch('/api/usage', { method: 'GET' });
    const payload = await res.json().catch(() => null);
    if (res.ok) {
      applyQuotaPayload(payload || {}, options);
    } else {
      const message = payload?.error || `usage fetch failed (${res.status})`;
      quotaState.error = message;
      if (!options || options.silent !== true) {
        console.warn(message);
      }
    }
  } catch (err) {
    quotaState.error = err;
    if (!options || options.silent !== true) {
      console.warn('refreshUsageState failed', err);
    }
  } finally {
    quotaState.loading = false;
  }
  return quotaState;
}

async function reserveQuotaUsage(type, amount = 1) {
  const normalizedType = typeof type === 'string' ? type.trim().toLowerCase() : '';
  if (!normalizedType) throw new Error('type is required');
  const payload = { type: normalizedType, amount }; // optimistic payload; server validates amount
  try {
    const res = await authedFetch('/api/usage', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    const body = await res.json().catch(() => null);
    if (res.status === 429) {
      applyQuotaPayload(body || {}, { silent: true });
      throw new QuotaError('AIÂà©Áî®ÂõûÊï∞„ÅÆ‰∏äÈôê„Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ', body?.limitExceeded || null);
    }
    if (!res.ok) {
      const message = body?.error || `usage update failed (${res.status})`;
      throw new Error(message);
    }
    applyQuotaPayload(body || {}, { silent: false });
    return body;
  } catch (err) {
    if (err instanceof QuotaError) throw err;
    quotaState.error = err;
    throw err;
  }
}

function updateAllQuotaDisplays() {
  if (!Array.isArray(sentences)) return;
  for (let idx = 0; idx < sentences.length; idx += 1) {
    updateEvaluationQuotaDisplay('listening', idx);
    updateEvaluationQuotaDisplay('translation', idx);
    updatePronunciationQuotaDisplay(idx);
  }
}

function evaluationHistoryKey(type, idx) {
  return `${type}History_${idx}`;
}

function normalizeScoreValue(value) {
  const num = Number(value);
  if (!Number.isFinite(num)) return null;
  const clamped = Math.max(0, Math.min(100, num));
  return Math.round(clamped);
}

function sanitizeHistoryEntry(entry) {
  if (!entry || typeof entry !== 'object') return null;
  const input = String(entry.input ?? entry.listen ?? entry.student ?? '').trim();
  const feedback = String(entry.feedback ?? entry.result ?? entry.response ?? '').trim();
  const score = normalizeScoreValue(entry.score ?? entry.points ?? entry.rating);
  if (!input && !feedback && score === null) return null;
  const rawTs = entry.createdAt || entry.savedAt || entry.timestamp || entry.time;
  let iso = null;
  if (rawTs) {
    const parsed = new Date(rawTs);
    if (!Number.isNaN(parsed.getTime())) iso = parsed.toISOString();
  }
  if (!iso) iso = new Date().toISOString();
  return { input, feedback, score, createdAt: iso };
}

function parseEvaluationScorePayload(rawText) {
  const fallback = { score: null, feedback: (rawText || '').trim() };
  if (!rawText || typeof rawText !== 'string') return fallback;
  let candidate = rawText.trim();
  if (!candidate) return fallback;
  if (!candidate.startsWith('{')) {
    const match = candidate.match(/\{[\s\S]*\}/);
    if (match && match[0]) {
      candidate = match[0];
    }
  }
  try {
    const parsed = JSON.parse(candidate);
    const score = normalizeScoreValue(parsed.score);
    const feedbackText = String(parsed.feedback ?? '').trim();
    return {
      score,
      feedback: feedbackText || fallback.feedback
    };
  } catch (err) {
    console.warn('parseEvaluationScorePayload failed', err);
    return fallback;
  }
}

function loadEvaluationHistory(type, idx) {
  const raw = storageGet(evaluationHistoryKey(type, idx));
  if (!raw) return [];
  try {
    const parsed = JSON.parse(raw);
    if (Array.isArray(parsed)) {
      return parsed
        .map(sanitizeHistoryEntry)
        .filter(Boolean)
        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
    }
  } catch (e) {
    console.warn('loadEvaluationHistory parse failed', e);
  }
  return [];
}

const TREND_ID_RESOLVER = {
  listening: idx => `listeningTrend_${idx}`,
  translation: idx => `translationTrend_${idx}`,
  pronunciation: idx => `pronunciationTrend_${idx}`
};

function normalizeTrendType(type) {
  if (type === 'translation' || type === 'pronunciation') return type;
  return 'listening';
}

function computeScoreTrendSnapshot(type, idx, historyOverride = null) {
  const normalized = normalizeTrendType(type);
  const history = Array.isArray(historyOverride) ? historyOverride : loadEvaluationHistory(normalized, idx);
  const recentDesc = [];
  for (const entry of history) {
    const score = Number(entry?.score);
    if (Number.isFinite(score)) {
      recentDesc.push(score);
      if (recentDesc.length >= 3) break;
    }
  }
  if (!recentDesc.length) {
    return {
      normalized,
      text: '',
      title: '„Çπ„Ç≥„Ç¢Ë®òÈå≤„Åå„ÅÇ„Çä„Åæ„Åõ„Çì',
      latest: null,
      best: null,
      sequenceCompact: ''
    };
  }
  const chronological = recentDesc.slice().reverse();
  const display = chronological.map(score => `${score}ÁÇπ`).join(' ‚Üí ');
  const latest = chronological[chronological.length - 1];
  const previous = chronological.length >= 2 ? chronological[chronological.length - 2] : null;
  let deltaText = '';
  if (previous !== null) {
    const delta = latest - previous;
    if (delta > 0) deltaText = ` (‚Üë+${delta})`;
    else if (delta < 0) deltaText = ` (‚Üì${Math.abs(delta)})`;
  }
  const best = chronological.reduce((max, score) => Math.max(max, score), -Infinity);
  const sequenceCompact = chronological.map(score => `${score}`).join(' ‚Üí ');
  return {
    normalized,
    text: `${display}${deltaText}`,
    title: `ÊúÄÊñ∞: ${latest}ÁÇπ / ÊúÄÈ´ò: ${best}ÁÇπ`,
    latest,
    best,
    sequenceCompact
  };
}

function updateScoreTrend(type, idx, historyOverride = null) {
  const snapshot = computeScoreTrendSnapshot(type, idx, historyOverride);
  const resolver = TREND_ID_RESOLVER[snapshot.normalized];
  const trendEl = resolver ? document.getElementById(resolver(idx)) : null;
  if (trendEl) {
    trendEl.textContent = snapshot.text;
    trendEl.title = snapshot.title;
  }
  return snapshot;
}

function getEntryTrendSegments(idx, overrides = {}) {
  const types = ['listening', 'translation', 'pronunciation'];
  const segments = [];
  types.forEach(type => {
    const snapshot = overrides[type] || computeScoreTrendSnapshot(type, idx);
    if (snapshot.text) {
      const label = type === 'translation' ? 'ÂíåË®≥' : (type === 'pronunciation' ? 'Áô∫Èü≥' : 'ËÅû„ÅçÂèñ„Çä');
      const sequence = (snapshot.sequenceCompact || snapshot.text).replace(/\s*‚Üí\s*/g, ' ‚Üí ');
      segments.push({ type, label, sequence, title: snapshot.title });
    }
  });
  return segments;
}

function saveEvaluationHistory(type, idx, history) {
  const clean = Array.isArray(history)
    ? history.map(sanitizeHistoryEntry).filter(Boolean)
    : [];
  try {
    storageSet(evaluationHistoryKey(type, idx), JSON.stringify(clean.slice(0, EVAL_HISTORY_LIMIT)));
  } catch (e) {
    console.warn('saveEvaluationHistory failed', e);
  }
}

function deleteEvaluationHistoryEntry(type, idx, entryKey) {
  const key = typeof entryKey === 'string' ? entryKey : '';
  if (!key) return loadEvaluationHistory(type, idx);
  const current = loadEvaluationHistory(type, idx);
  const filtered = current.filter(entry => evaluationHistoryEntryKey(entry) !== key);
  saveEvaluationHistory(type, idx, filtered);
  renderEvaluationHistory(type, idx, filtered);
  return filtered;
}

function mergeHistoryEntries(primaryEntries, secondaryEntries = []) {
  const merged = [];
  const seen = new Set();
  const pushEntry = (entry) => {
    const clean = sanitizeHistoryEntry(entry);
    if (!clean) return;
    const key = evaluationHistoryEntryKey(clean);
    if (seen.has(key)) return;
    seen.add(key);
    merged.push(clean);
  };
  [...(Array.isArray(primaryEntries) ? primaryEntries : []), ...(Array.isArray(secondaryEntries) ? secondaryEntries : [])].forEach(pushEntry);
  merged.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  return merged.slice(0, EVAL_HISTORY_LIMIT);
}

function evaluationHistoryEntryKey(entry) {
  if (!entry || typeof entry !== 'object') return '';
  const created = entry.createdAt || '';
  const input = entry.input || '';
  const feedback = entry.feedback || '';
  const score = Number.isFinite(entry.score) ? String(entry.score) : '';
  return `${created}__${input}__${feedback}__${score}`;
}

function formatHistoryTimestamp(raw) {
  if (!raw) return '';
  try {
    const date = new Date(raw);
    if (Number.isNaN(date.getTime())) return '';
    return date.toLocaleString('ja-JP', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
  } catch (err) {
    console.warn('formatHistoryTimestamp failed', err);
    return '';
  }
}

function encodeHistoryEntryKey(rawKey) {
  if (!rawKey) return '';
  try {
    const bytes = new TextEncoder().encode(String(rawKey));
    let binary = '';
    bytes.forEach(byte => { binary += String.fromCharCode(byte); });
    return btoa(binary);
  } catch (primaryErr) {
    try {
      return btoa(unescape(encodeURIComponent(String(rawKey))));
    } catch (secondaryErr) {
      console.warn('encodeHistoryEntryKey failed', primaryErr, secondaryErr);
      return '';
    }
  }
}

function decodeHistoryEntryKey(encodedKey) {
  if (!encodedKey) return '';
  try {
    const binary = atob(encodedKey);
    const bytes = Uint8Array.from(binary, char => char.charCodeAt(0));
    return new TextDecoder().decode(bytes);
  } catch (primaryErr) {
    console.warn('decodeHistoryEntryKey failed', primaryErr);
    return '';
  }
}

function renderEvaluationHistory(type, idx, entries) {
  const history = Array.isArray(entries) ? entries : loadEvaluationHistory(type, idx);
  const container = document.getElementById(`${type}History_${idx}`);
  if (!container) {
    updateScoreTrend(type, idx, history);
    return;
  }
  container.innerHTML = '';
  if (!history.length) {
    const empty = document.createElement('div');
    empty.className = 'history-empty';
    empty.textContent = type === 'translation' ? '„Åæ„Å†ÁøªË®≥Ë©ï‰æ°„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ' : '„Åæ„Å†„É™„Çπ„Éã„É≥„Ç∞Ë©ï‰æ°„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ';
    container.appendChild(empty);
    if (type === 'listening' || type === 'translation') {
      updateEvaluationQuotaDisplay(type, idx);
    }
    updateScoreTrend(type, idx, history);
    return;
  }
  history.forEach(entry => {
    const wrapper = document.createElement('div');
    wrapper.className = 'history-entry';

    const header = document.createElement('div');
    header.className = 'history-entry-header';
    const timeEl = document.createElement('time');
    timeEl.textContent = formatHistoryTimestamp(entry.createdAt) || 'Êó•ÊôÇ‰∏çÊòé';
    header.appendChild(timeEl);
    if (Number.isFinite(entry?.score)) {
      const scoreEl = document.createElement('span');
      scoreEl.className = 'history-score';
      scoreEl.textContent = `„Çπ„Ç≥„Ç¢ ${entry.score}ÁÇπ`;
      header.appendChild(scoreEl);
    }
    const deleteBtn = document.createElement('button');
    deleteBtn.type = 'button';
    deleteBtn.className = 'history-delete';
    deleteBtn.textContent = 'ÂâäÈô§';
    deleteBtn.dataset.type = type;
    deleteBtn.dataset.idx = String(idx);
    deleteBtn.dataset.key = encodeHistoryEntryKey(evaluationHistoryEntryKey(entry));
    header.appendChild(deleteBtn);
    wrapper.appendChild(header);

    const inputRow = document.createElement('div');
    inputRow.className = 'history-row';
    const inputLabel = document.createElement('span');
    inputLabel.className = 'history-label';
    inputLabel.textContent = 'ÂÖ•Âäõ';
    const inputText = document.createElement('div');
    inputText.className = 'history-text';
    inputText.textContent = entry?.input || '';
    inputRow.appendChild(inputLabel);
    inputRow.appendChild(inputText);
    wrapper.appendChild(inputRow);

    const feedbackRow = document.createElement('div');
    feedbackRow.className = 'history-row';
    const feedbackLabel = document.createElement('span');
    feedbackLabel.className = 'history-label';
    feedbackLabel.textContent = 'Ë©ï‰æ°';
    const feedbackText = document.createElement('div');
    feedbackText.className = 'history-text';
    feedbackText.textContent = entry?.feedback || '';
    feedbackRow.appendChild(feedbackLabel);
    feedbackRow.appendChild(feedbackText);
    wrapper.appendChild(feedbackRow);

    container.appendChild(wrapper);
  });
  if (type === 'listening' || type === 'translation') {
    updateEvaluationQuotaDisplay(type, idx);
  }
  updateScoreTrend(type, idx, history);
}

function appendEvaluationHistory(type, idx, input, feedback, score = null, createdAt = null, options = {}) {
  const baseEntry = sanitizeHistoryEntry({ input, feedback, score, createdAt });
  if (!baseEntry) return;
  const current = loadEvaluationHistory(type, idx);
  if (!options.allowDuplicate) {
    const exists = current.some(entry => entry.input === baseEntry.input && entry.feedback === baseEntry.feedback && entry.createdAt === baseEntry.createdAt);
    if (exists) {
      renderEvaluationHistory(type, idx, current);
      return;
    }
  }
  const merged = mergeHistoryEntries([baseEntry, ...current]);
  saveEvaluationHistory(type, idx, merged);
  renderEvaluationHistory(type, idx, merged);
}

function getEvaluationHistoryCount(type, idx) {
  return loadEvaluationHistory(type, idx).length;
}

function normalizeEvaluationType(type) {
  return type === 'translation' ? 'translation' : 'listening';
}

function evaluationAttemptsKey(type, idx) {
  const normalized = normalizeEvaluationType(type);
  return `${normalized}Attempts_${idx}`;
}

function getStoredEvaluationAttempts(type, idx) {
  try {
    const raw = storageGet(evaluationAttemptsKey(type, idx));
    const num = Number(raw);
    if (!Number.isFinite(num) || num < 0) return 0;
    return Math.floor(num);
  } catch (err) {
    console.warn('getStoredEvaluationAttempts failed', err);
    return 0;
  }
}

function setStoredEvaluationAttempts(type, idx, value) {
  try {
    storageSet(evaluationAttemptsKey(type, idx), String(Math.max(0, Math.floor(value))));
  } catch (err) {
    console.warn('setStoredEvaluationAttempts failed', err);
  }
}

function getEvaluationAttempts(type, idx) {
  const normalized = normalizeEvaluationType(type);
  const stored = getStoredEvaluationAttempts(normalized, idx);
  const historyCount = getEvaluationHistoryCount(normalized, idx);
  if (historyCount > stored) {
    setStoredEvaluationAttempts(normalized, idx, historyCount);
    return historyCount;
  }
  return stored;
}

function incrementEvaluationAttempts(type, idx) {
  const normalized = normalizeEvaluationType(type);
  const next = getEvaluationAttempts(normalized, idx) + 1;
  setStoredEvaluationAttempts(normalized, idx, next);
  return next;
}

function updateEvaluationQuotaDisplay(type, idx) {
  const el = document.getElementById(`${type}Quota_${idx}`);
  if (!el) return;
  const limit = type === 'translation' ? sectionLimits.translation : sectionLimits.listening;
  const label = type === 'translation' ? 'ÂíåË®≥Ë©ï‰æ°' : 'ËÅû„ÅçÂèñ„ÇäË©ï‰æ°';
  try {
    const count = getEvaluationAttempts(type, idx);
    const sectionRemaining = Number.isFinite(limit) ? Math.max(0, Math.floor(limit) - count) : Infinity;
    const globalRemaining = getGlobalQuotaRemaining(type);
    const remaining = Number.isFinite(sectionRemaining)
      ? (Number.isFinite(globalRemaining) ? Math.min(sectionRemaining, globalRemaining) : sectionRemaining)
      : globalRemaining;
    const remainingDisplay = Number.isFinite(remaining) ? remaining : '‚àû';
    el.textContent = `ÊÆã„Çä${remainingDisplay}Âõû`;
    const exhausted = (Number.isFinite(remaining) && remaining <= 0) || (Number.isFinite(globalRemaining) && globalRemaining <= 0);
    el.style.color = exhausted ? '#b91c1c' : '#059669';
    if (Number.isFinite(limit)) {
      if (Number.isFinite(globalRemaining)) {
        el.title = `${label}„ÅØ1„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Å§„Åç${limit}Âõû„Åæ„ÅßÔºàÂÖ®‰ΩìÊÆã„Çä${globalRemaining}ÂõûÔºâ`;
      } else {
        el.title = `${label}„ÅØ1„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Å§„Åç${limit}Âõû„Åæ„Åß`;
      }
    } else {
      if (Number.isFinite(globalRemaining)) {
        el.title = `${label}„ÅÆ„É≠„Éº„Ç´„É´‰∏äÈôê„ÅØ„ÅÇ„Çä„Åæ„Åõ„ÇìÔºàÂÖ®‰ΩìÊÆã„Çä${globalRemaining}ÂõûÔºâ`;
      } else {
        el.title = `${label}„ÅÆ„É≠„Éº„Ç´„É´‰∏äÈôê„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì`;
      }
    }
  } catch (err) {
    console.warn('updateEvaluationQuotaDisplay failed', type, idx, err);
  }
}

function pronunciationAttemptsKey(idx) {
  return `pronunciationAttempts_${idx}`;
}

function getStoredPronunciationAttempts(idx) {
  const raw = storageGet(pronunciationAttemptsKey(idx));
  const n = Number(raw);
  return Number.isFinite(n) && n >= 0 ? Math.floor(n) : 0;
}

function setPronunciationAttempts(idx, count) {
  storageSet(pronunciationAttemptsKey(idx), String(Math.max(0, Math.floor(count))));
}

function getPronunciationAssessmentCount(idx) {
  const recList = document.getElementById(`recList_${idx}`);
  if (!recList) return 0;
  return Array.from(recList.querySelectorAll('.rec-card')).filter(card => card.dataset.assessed === 'true').length;
}

function getPronunciationAttempts(idx) {
  return Math.max(getStoredPronunciationAttempts(idx), getPronunciationAssessmentCount(idx));
}

function incrementPronunciationAttempts(idx) {
  const currentStored = getStoredPronunciationAttempts(idx);
  const assessedCount = getPronunciationAssessmentCount(idx);
  const next = Math.max(currentStored + 1, assessedCount);
  setPronunciationAttempts(idx, next);
  return next;
}

function isPronunciationLimitReached(idx) {
  try {
    if (isGlobalQuotaExhausted('pronunciation')) return true;
    if (!Number.isFinite(sectionLimits.pronunciation)) return false;
    return getPronunciationAttempts(idx) >= Math.floor(sectionLimits.pronunciation);
  } catch (e) {
    console.warn('isPronunciationLimitReached failed', e);
    return false;
  }
}

function updatePronunciationQuotaDisplay(idx) {
  const recQuota = document.getElementById(`recQuota_${idx}`);
  if (!recQuota) return;
  try {
    const attempts = getPronunciationAttempts(idx);
    const localLimit = sectionLimits.pronunciation;
    const localRemaining = Number.isFinite(localLimit)
      ? Math.max(0, Math.floor(localLimit) - attempts)
      : Infinity;
    const globalRemaining = getGlobalQuotaRemaining('pronunciation');
    const remaining = Number.isFinite(localRemaining)
      ? (Number.isFinite(globalRemaining) ? Math.min(localRemaining, globalRemaining) : localRemaining)
      : globalRemaining;
    const displayValue = Number.isFinite(remaining) ? remaining : '‚àû';
    recQuota.textContent = `ÊÆã„Çä${displayValue}Âõû`;
    const exhausted = (Number.isFinite(remaining) && remaining <= 0) || (Number.isFinite(globalRemaining) && globalRemaining <= 0);
    recQuota.style.color = exhausted ? '#b91c1c' : '#059669';
    if (Number.isFinite(localLimit)) {
      if (Number.isFinite(globalRemaining)) {
        recQuota.title = `Áô∫Èü≥Ë©ï‰æ°„ÅØ1„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Å§„Åç${localLimit}Âõû„Åæ„ÅßÔºàÂÖ®‰ΩìÊÆã„Çä${globalRemaining}ÂõûÔºâ`;
      } else {
        recQuota.title = `Áô∫Èü≥Ë©ï‰æ°„ÅØ1„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Å§„Åç${localLimit}Âõû„Åæ„Åß`;
      }
    } else {
      if (Number.isFinite(globalRemaining)) {
        recQuota.title = `Áô∫Èü≥Ë©ï‰æ°„ÅÆ„É≠„Éº„Ç´„É´‰∏äÈôê„ÅØ„ÅÇ„Çä„Åæ„Åõ„ÇìÔºàÂÖ®‰ΩìÊÆã„Çä${globalRemaining}ÂõûÔºâ`;
      } else {
        recQuota.title = 'Áô∫Èü≥Ë©ï‰æ°„ÅÆ„É≠„Éº„Ç´„É´‰∏äÈôê„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì';
      }
    }
  } catch (err) {
    console.warn('updatePronunciationQuotaDisplay failed', err);
  }
}

function setPronunciationLimitMessage(statusEl) {
  if (!statusEl) return;
  if (isGlobalQuotaExhausted('pronunciation')) {
    statusEl.textContent = 'AIÂà©Áî®ÂõûÊï∞„ÅÆ‰∏äÈôê„Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ';
  } else if (Number.isFinite(sectionLimits.pronunciation)) {
    statusEl.textContent = `Áô∫Èü≥Ë©ï‰æ°„ÅØ1„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Å§„Åç${sectionLimits.pronunciation}Âõû„Åæ„Åß„Åß„Åô„ÄÇ`;
  }
}

function computePagePrefix() {
  const safeUser = sanitizeUserIdForClient(authState.userId || 'anon');
  let p = location.host + location.pathname;
  p = p.replace(/[^A-Za-z0-9._\-/]/g, '_');
  if (!p.endsWith('/')) p += '/';
  return `${safeUser}/${p}`;
}

async function validateToken() {
  if (!authState.token) return false;
  try {
    const res = await fetch('/api/auth', {
      method: 'GET',
      headers: { Authorization: `Bearer ${authState.token}` }
    });
    if (!res.ok) return false;
    const data = await res.json().catch(() => null);
    if (!data || !data.userId) return false;
    authState.userId = data.userId;
    if (data.expiresAt) authState.expiresAt = data.expiresAt;
  updateAuthBar();
    return true;
  } catch (e) {
    console.warn('token validation failed', e);
    return false;
  }
}

function buildLoginOverlay() {
  const overlay = document.createElement('div');
  overlay.id = 'authOverlay';
  overlay.style = `position:fixed;inset:0;background:rgba(17,24,39,0.85);display:flex;align-items:center;justify-content:center;z-index:9999;`;
  overlay.innerHTML = `
    <div style="background:#fff;border-radius:12px;padding:24px;max-width:360px;width:92%;box-shadow:0 12px 30px rgba(0,0,0,0.25);">
      <h2 style="margin:0 0 16px 0;font-size:1.25rem;color:#111827;text-align:center;">„É≠„Ç∞„Ç§„É≥</h2>
      <form id="authForm" style="display:flex;flex-direction:column;gap:12px;">
        <label style="display:flex;flex-direction:column;font-size:0.95rem;color:#374151;gap:4px;">
          „É¶„Éº„Ç∂„ÉºID
          <input type="text" name="userId" required style="padding:0.6rem;border:1px solid #d1d5db;border-radius:6px;font-size:1rem;" autocomplete="username" />
        </label>
        <label class="auth-password-field" style="display:flex;flex-direction:column;font-size:0.95rem;color:#374151;gap:4px;">
          „Éë„Çπ„ÉØ„Éº„Éâ
          <input type="password" name="password" required style="padding:0.6rem;border:1px solid #d1d5db;border-radius:6px;font-size:1rem;" autocomplete="current-password" />
          <span class="auth-password-hint" style="display:none;font-size:0.8rem;color:#6b7280;">acg2_„ÅßÂßã„Åæ„ÇãID„ÅØ„Éë„Çπ„ÉØ„Éº„Éâ‰∏çË¶Å„Åß„Åô„ÄÇ</span>
        </label>
        <button type="submit" style="margin-top:4px;background:#2563eb;color:#fff;padding:0.65rem;border-radius:6px;font-size:1rem;font-weight:600;border:none;cursor:pointer;">„É≠„Ç∞„Ç§„É≥</button>
        <div id="authStatus" style="min-height:1.2rem;font-size:0.9rem;color:#dc2626;text-align:center;"></div>
      </form>
    </div>
  `;
  return overlay;
}

async function promptForLogin() {
  return new Promise(resolve => {
    const overlay = buildLoginOverlay();
    document.body.appendChild(overlay);
    const form = overlay.querySelector('#authForm');
    const statusEl = overlay.querySelector('#authStatus');
    const userInput = form?.querySelector('input[name="userId"]');
    const passwordInput = form?.querySelector('input[name="password"]');
    const passwordHint = form?.querySelector('.auth-password-hint');
    const togglePasswordState = (value) => {
      const raw = typeof value === 'string' ? value.trim() : '';
      const optional = raw.startsWith(PASSWORD_OPTIONAL_PREFIX);
      if (passwordInput) {
        passwordInput.disabled = optional;
        passwordInput.required = !optional;
        if (optional) passwordInput.value = '';
      }
      if (passwordHint) passwordHint.style.display = optional ? 'block' : 'none';
    };
    if (userInput) {
      togglePasswordState(userInput.value);
      userInput.addEventListener('input', (ev) => togglePasswordState(ev.target.value));
    }
    let busy = false;
    form.addEventListener('submit', async (ev) => {
      ev.preventDefault();
      if (busy) return;
      busy = true;
      statusEl.textContent = '';
      const formData = new FormData(form);
      const userId = String(formData.get('userId') || '').trim();
      const password = String(formData.get('password') || '');
      const passwordOptional = userId.startsWith(PASSWORD_OPTIONAL_PREFIX);
      if (!userId) {
        statusEl.textContent = '„É¶„Éº„Ç∂„ÉºID„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ';
        busy = false;
        return;
      }
      if (!passwordOptional && !password) {
        statusEl.textContent = '„Åì„ÅÆID„Å´„ÅØ„Éë„Çπ„ÉØ„Éº„Éâ„ÅåÂøÖË¶Å„Åß„Åô';
        busy = false;
        return;
      }
      try {
        const res = await fetch('/api/auth', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userId, password: passwordOptional ? '' : password })
        });
        if (!res.ok) {
          const text = await res.text();
          let msg = 'Ë™çË®º„Å´Â§±Êïó„Åó„Åæ„Åó„Åü';
          try {
            const parsed = JSON.parse(text);
            if (parsed && parsed.error) msg = parsed.error;
          } catch {}
          statusEl.textContent = msg;
          busy = false;
          return;
        }
        const data = await res.json();
        const now = Date.now();
        const expiresInMs = (data.expiresIn || 3600) * 1000;
        setAuthState(data.token, data.userId, now + expiresInMs);
        overlay.remove();
        resolve(authState);
      } catch (e) {
        console.warn('login request failed', e);
        statusEl.textContent = '„Çµ„Éº„Éê„Éº„Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü';
        busy = false;
      }
    });
  });
}

async function ensureAuthenticated() {
  const now = Date.now();
  if (authState.token && authState.expiresAt && authState.expiresAt > now + 5000) {
    return authState;
  }
  const stored = loadAuthFromStorage();
  if (stored && stored.token) {
    authState.token = stored.token;
    authState.userId = stored.userId;
    authState.expiresAt = stored.expiresAt;
    if (stored.expiresAt && stored.expiresAt > Date.now() + 5000) {
      const ok = await validateToken();
      if (ok) return authState;
    }
  }
  clearAuthState();
  return promptForLogin();
}

async function authedFetch(input, init = {}, retry = true) {
  await ensureAuthenticated();
  const options = Object.assign({}, init || {});
  const headers = new Headers(options.headers || {});
  if (authState.token) headers.set('Authorization', `Bearer ${authState.token}`);
  options.headers = headers;
  const response = await fetch(input, options);
  if (response.status === 401 && retry) {
    clearAuthState();
    await ensureAuthenticated();
    PAGE_PREFIX = computePagePrefix();
    currentAuthUserId = authState.userId;
    window.location.reload();
    throw new Error('„Çª„ÉÉ„Ç∑„Éß„É≥„ÅåÂàá„Çå„Åü„Åü„ÇÅ„Éö„Éº„Ç∏„ÇíÂÜçË™≠„ÅøËæº„Åø„Åó„Åæ„Åô');
  }
  return response;
}

function requireAuthGuard() {
  if (!authState.userId) {
    throw new Error('Ë™çË®ºÊÉÖÂ†±„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
  }
}

function updateEntrySummary(idx) {
  const statusEl = document.getElementById(`status${idx}`);
  const snippetEl = document.getElementById(`summarySnippet_${idx}`);
  const entryEl = document.querySelector(`.entry[data-section="${idx}"]`);
  if (!statusEl && !snippetEl) return;

  const noteInput = document.getElementById(`note_${idx}_input`);
  const transInput = document.getElementById(`trans_${idx}_input`);
  const noteVal = (noteInput?.value || "").trim();
  const transVal = (transInput?.value || "").trim();

  let listeningHistoryCount = 0;
  let translationHistoryCount = 0;
  try { listeningHistoryCount = getEvaluationHistoryCount('listening', idx); } catch (e) {}
  try { translationHistoryCount = getEvaluationHistoryCount('translation', idx); } catch (e) {}

  const recList = document.getElementById(`recList_${idx}`);
  const recCount = recList ? recList.querySelectorAll('.rec-card').length : 0;
  const syncText = document.getElementById(`syncStatus_${idx}`)?.textContent?.trim() || "";
  const isDirty = entryEl?.dataset?.dirty === '1';

  const trendSegments = getEntryTrendSegments(idx);
  const segmentMap = trendSegments.reduce((acc, seg) => {
    acc[seg.type] = seg;
    return acc;
  }, {});

  const listeningDone = listeningHistoryCount > 0;
  const translationDone = translationHistoryCount > 0;
  const recordingDone = recCount > 0;
  if (statusEl) {
    const statusConfigs = [
      { type: 'listening', label: 'ËÅû„ÅçÂèñ„Çä', done: listeningDone },
      { type: 'translation', label: 'ÂíåË®≥', done: translationDone },
      { type: 'pronunciation', label: 'Áô∫Èü≥', done: recordingDone }
    ];
    const statuses = statusConfigs.map(cfg => {
      const mark = cfg.done ? '‚úÖ' : '‚¨ú';
      const seg = segmentMap[cfg.type];
      const seqText = (cfg.done && seg && seg.sequence) ? ` ${seg.sequence}` : '';
      return `${cfg.label}${mark}${seqText}`;
    });
    statusEl.textContent = statuses.join('„ÄÄ');
    const extras = [];
    if (isDirty) extras.push('Êú™‰øùÂ≠ò„ÅÆÂ§âÊõ¥„ÅÇ„Çä');
    if (/‰øùÂ≠ò‰∏≠/.test(syncText)) extras.push('‰øùÂ≠ò‰∏≠');
    else if (/‰øùÂ≠òÊ∏à/.test(syncText) || /Ë™≠„ÅøËæº„Åø/.test(syncText)) extras.push('„Çµ„Éº„Éê„Éº„Å®ÂêåÊúüÊ∏à„Åø');
    else if (/Â§±Êïó/.test(syncText)) extras.push('‰øùÂ≠ò„Å´Â§±Êïó');
    else if (/„ÅÇ„Çä„Åæ„Åõ„Çì/.test(syncText)) extras.push('„Çµ„Éº„Éê„Éº„Éá„Éº„Çø„Å™„Åó');
    if (trendSegments.length) {
      extras.push(trendSegments.map(seg => `${seg.label}: ${seg.sequence}`).join(' / '));
    }
    statusEl.title = extras.length ? extras.join(' / ') : '';
  }

  if (snippetEl) {
    snippetEl.textContent = '';
    snippetEl.style.display = 'none';
  }
}

const totalSections = sentences.length;

function buildSections() {
  requireAuthGuard();
  container.innerHTML = '';
  sentences.forEach((sentence, idx) => {
    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
    <details class="entry" data-section="${idx}">
      <summary>
        <span class="entry-title">${idx + 1}/${totalSections}</span>
        <span class="entry-status" id="status${idx}">ËÅû„ÅçÂèñ„Çä‚¨ú„ÄÄÂíåË®≥‚¨ú„ÄÄÁô∫Èü≥‚¨ú</span>
        <span class="entry-snippet" id="summarySnippet_${idx}" style="display:none;"></span>
      </summary>
      <div class="entry-body">
        <audio controls src="${base}/${idx + 1}.mp3"></audio>
        <div id="syncStatus_${idx}" style="font-size:0.9rem;color:#4b5563;margin-bottom:10px"></div>
    <button class="collapsible script-toggle primary-script">üìú „Çπ„ÇØ„É™„Éó„Éà„ÇíË°®Á§∫</button>
    <div class="content script-content primary-script-content" style="display:none;"></div>
        <div class="evaluation-block listening-block" data-idx="${idx}">
          <div class="evaluation-header">
            <h3 class="evaluation-title">„É™„Çπ„Éã„É≥„Ç∞Ë©ï‰æ°</h3>
            <span class="score-trend" id="listeningTrend_${idx}"></span>
            <span class="eval-quota" id="listeningQuota_${idx}"></span>
            <button type="button" class="evaluation-toggle listening-toggle" data-idx="${idx}" aria-expanded="true">Ôºç Ë©≥Á¥∞„ÇíÈö†„Åô</button>
          </div>
          <div class="evaluation-body listening-body" id="listeningBody_${idx}" aria-hidden="false">
            <textarea id="note_${idx}_input" placeholder="ËÅû„Åì„Åà„ÅüÊñá„ÇíÂÖ•Âäõ‚Ä¶"></textarea>
            <div class="evaluation-actions">
              <button id="note_${idx}_compare">„É™„Çπ„Éã„É≥„Ç∞Ë©ï‰æ°</button>
            </div>
            <div class="evaluation-history" id="listeningHistory_${idx}"></div>
          </div>
        </div>
        <div class="evaluation-block translation-block" data-idx="${idx}">
          <div class="evaluation-header">
            <h3 class="evaluation-title">ÁøªË®≥Ë©ï‰æ°</h3>
            <span class="score-trend" id="translationTrend_${idx}"></span>
            <span class="eval-quota" id="translationQuota_${idx}"></span>
            <button type="button" class="evaluation-toggle translation-toggle" data-idx="${idx}" aria-expanded="true">Ôºç Ë©≥Á¥∞„ÇíÈö†„Åô</button>
          </div>
          <div class="evaluation-body translation-body" id="translationBody_${idx}" aria-hidden="false">
            <textarea id="trans_${idx}_input" placeholder="Êó•Êú¨Ë™ûË®≥„ÇíÂÖ•Âäõ‚Ä¶"></textarea>
            <div class="evaluation-actions">
              <button id="trans_${idx}_compare">ÁøªË®≥Ë©ï‰æ°</button>
            </div>
            <div class="evaluation-history" id="translationHistory_${idx}"></div>
          </div>
        </div>
        <div class="evaluation-block pronunciation-block" data-idx="${idx}">
          <div class="evaluation-header">
            <h3 class="evaluation-title">Áô∫Èü≥Ë©ï‰æ°</h3>
            <span class="score-trend" id="pronunciationTrend_${idx}"></span>
            <span class="eval-quota eval-quota-spacer" aria-hidden="true"></span>
            <button type="button" class="evaluation-toggle pronunciation-toggle" data-idx="${idx}" aria-expanded="true">Ôºç Ë©≥Á¥∞„ÇíÈö†„Åô</button>
          </div>
          <div class="evaluation-body pronunciation-body" id="pronunciationBody_${idx}" aria-hidden="false">
            <audio controls src="${base}/${idx + 1}.mp3" class="sample-audio" style="margin-top:0.5rem;margin-bottom:0.5rem;"></audio>
            <button class="collapsible script-toggle secondary-script">üìú „Çπ„ÇØ„É™„Éó„Éà„ÇíË°®Á§∫</button>
            <div class="content script-content secondary-script-content" style="display:none;"></div>
            <div class="pronunciation-controls">
              <button id="recToggle_${idx}" class="rec-toggle">üéôÔ∏è Èå≤Èü≥ÈñãÂßã</button>
              <span id="recStatus_${idx}" class="pronunciation-status"></span>
              <span id="recTimer_${idx}" class="pronunciation-timer"></span>
              <div class="pronunciation-actions">
                <span id="recQuota_${idx}" class="eval-quota"></span>
                <button id="submitBtn_${idx}" class="pronunciation-submit" disabled>Áô∫Èü≥Ë©ï‰æ°„ÇíÂÆüË°å</button>
              </div>
            </div>
            <pre id="result_${idx}" style="margin:0;padding:0;"></pre>
            <div id="pendingPreview_${idx}" class="pending-preview"></div>
            <div id="recList_${idx}" style="margin-top:10px;"></div>
            <div id="scoreBlock_${idx}"></div>
          </div>
        </div>
      </div>
    </details>
    `;
    container.appendChild(card);
    setupBlock(idx, sentence);
  });
}

function setupBlock(idx, sentence) {
  const cardRoot = container.children[idx];
  const entryEl = cardRoot?.querySelector(".entry");
  const primaryScriptBtn = cardRoot?.querySelector(".primary-script");
  const primaryScriptContent = cardRoot?.querySelector(".primary-script-content");
  const secondaryScriptBtn = cardRoot?.querySelector(".secondary-script");
  const secondaryScriptContent = cardRoot?.querySelector(".secondary-script-content");
  const listeningBlock = cardRoot?.querySelector('.listening-block');
  const listeningToggle = cardRoot?.querySelector(`.listening-toggle[data-idx="${idx}"]`);
  const listeningBody = document.getElementById(`listeningBody_${idx}`);
  const translationBlock = cardRoot?.querySelector('.translation-block');
  const translationToggle = cardRoot?.querySelector(`.translation-toggle[data-idx="${idx}"]`);
  const translationBody = document.getElementById(`translationBody_${idx}`);
  const pronunciationBlock = cardRoot?.querySelector('.pronunciation-block');
  const pronunciationToggle = cardRoot?.querySelector(`.pronunciation-toggle[data-idx="${idx}"]`);
  const pronunciationBody = document.getElementById(`pronunciationBody_${idx}`);

  const noteInput = document.getElementById(`note_${idx}_input`);
  const transInput = document.getElementById(`trans_${idx}_input`);
  const submitBtn = document.getElementById(`submitBtn_${idx}`);
  const pendingPreview = document.getElementById(`pendingPreview_${idx}`);
  let pendingPreviewUrl = null;
  const recToggleBtn = document.getElementById(`recToggle_${idx}`);

  if (entryEl) entryEl.dataset.dirty = '0';

  if (listeningBlock && listeningToggle && listeningBody) {
    listeningToggle.addEventListener('click', () => {
      const collapsed = listeningBlock.classList.toggle('collapsed');
      listeningToggle.textContent = collapsed ? 'Ôºã Ë©≥Á¥∞„ÇíË°®Á§∫' : 'Ôºç Ë©≥Á¥∞„ÇíÈö†„Åô';
      listeningToggle.setAttribute('aria-expanded', String(!collapsed));
      listeningBody.setAttribute('aria-hidden', String(collapsed));
    });
  }

  if (translationBlock && translationToggle && translationBody) {
    translationToggle.addEventListener('click', () => {
      const collapsed = translationBlock.classList.toggle('collapsed');
      translationToggle.textContent = collapsed ? 'Ôºã Ë©≥Á¥∞„ÇíË°®Á§∫' : 'Ôºç Ë©≥Á¥∞„ÇíÈö†„Åô';
      translationToggle.setAttribute('aria-expanded', String(!collapsed));
      translationBody.setAttribute('aria-hidden', String(collapsed));
    });
  }

  if (pronunciationBlock && pronunciationToggle && pronunciationBody) {
    pronunciationToggle.addEventListener('click', () => {
      const collapsed = pronunciationBlock.classList.toggle('collapsed');
      pronunciationToggle.textContent = collapsed ? 'Ôºã Ë©≥Á¥∞„ÇíË°®Á§∫' : 'Ôºç Ë©≥Á¥∞„ÇíÈö†„Åô';
      pronunciationToggle.setAttribute('aria-expanded', String(!collapsed));
      pronunciationBody.setAttribute('aria-hidden', String(collapsed));
    });
  }

  if (entryEl) {
    entryEl.addEventListener("toggle", () => {
      entryEl.classList.toggle("expanded", entryEl.open);
      if (entryEl.open) {
        container.querySelectorAll('.entry').forEach(section => {
          if (section !== entryEl && section.open) section.open = false;
        });
        fetchRemoteNotes(true);
        fetchAssessmentsForSection(true);
        setTimeout(() => {
          document.getElementById(`note_${idx}_input`)?.focus({ preventScroll: false });
        }, 50);
      } else {
        saveNotesToServer(idx);
      }
      updateEntrySummary(idx);
    });
  }

  if (primaryScriptContent) primaryScriptContent.textContent = sentence;
  if (secondaryScriptContent) secondaryScriptContent.textContent = sentence;
  noteInput.value = storageGet(`note_${idx}`) || "";
  transInput.value = storageGet(`trans_${idx}`) || "";
  renderEvaluationHistory('listening', idx);
  renderEvaluationHistory('translation', idx);
  updateScoreTrend('pronunciation', idx);
  updateEntrySummary(idx);
  setTimeout(() => {
    fetchAssessmentsForSection().catch(err => console.warn('prefetch assessments failed', err));
  }, idx * 150);

  let remoteNoteLoading = false;
  let notesLoaded = false;
  let notesDirty = false;
  let assessmentsLoaded = false;
  let assessmentLoading = false;

  const listeningHistoryEl = document.getElementById(`listeningHistory_${idx}`);
  const translationHistoryEl = document.getElementById(`translationHistory_${idx}`);

  const attachHistoryDeletion = (historyEl, historyType) => {
    if (!historyEl) return;
    historyEl.addEventListener('click', async (event) => {
      const button = event.target.closest('.history-delete');
      if (!button) return;
      event.preventDefault();
      const encodedKey = button.dataset.key || '';
      const entryKey = decodeHistoryEntryKey(encodedKey);
      if (!entryKey) return;
      if (!confirm('„Åì„ÅÆË©ï‰æ°„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) return;
      button.disabled = true;
      try {
        const beforeLength = loadEvaluationHistory(historyType, idx).length;
        const filtered = deleteEvaluationHistoryEntry(historyType, idx, entryKey);
        if (filtered.length === beforeLength) {
          return;
        }

        notesDirty = true;
        if (entryEl) entryEl.dataset.dirty = '1';
        const syncEl = document.getElementById(`syncStatus_${idx}`);
        if (syncEl) syncEl.textContent = '‰øùÂ≠ò‰∏≠‚Ä¶';
        updateEntrySummary(idx);

        const listeningVal = noteInput.value.trim();
        const translationVal = transInput.value.trim();
        const latestListeningHistory = loadEvaluationHistory('listening', idx);
        const latestTranslationHistory = loadEvaluationHistory('translation', idx);
        const pronunciationAttempts = getPronunciationAttempts(idx);
        const pagePrefix = PAGE_PREFIX || computePagePrefix();
        const payload = {
          key: pagePrefix + `notes_section_${idx}`,
          result: {
            listening: listeningVal,
            translation: translationVal,
            listeningHistory: latestListeningHistory,
            translationHistory: latestTranslationHistory,
            pronunciationAttempts,
            savedAt: new Date().toISOString()
          },
          referenceText: ''
        };

        const resp = await authedFetch('/api/assessment', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });

        if (!resp.ok) {
          const text = await resp.text().catch(() => '');
          throw new Error(`persist failed ${resp.status} ${text}`.trim());
        }

        notesDirty = false;
        if (entryEl) entryEl.dataset.dirty = '0';
        if (syncEl) syncEl.textContent = '‰øùÂ≠òÊ∏à„Åø';
      } catch (err) {
        console.warn('history delete persistence failed', err);
        const syncEl = document.getElementById(`syncStatus_${idx}`);
        if (syncEl) syncEl.textContent = '‰øùÂ≠ò„Å´Â§±Êïó';
        notesDirty = true;
        if (entryEl) entryEl.dataset.dirty = '1';
      } finally {
        button.disabled = false;
        updateEntrySummary(idx);
      }
    });
  };

  attachHistoryDeletion(listeningHistoryEl, 'listening');
  attachHistoryDeletion(translationHistoryEl, 'translation');

  async function fetchRemoteNotes(force = false) {
    if (remoteNoteLoading) return;
    if (notesLoaded && !force) return;
    remoteNoteLoading = true;
    const syncEl = document.getElementById(`syncStatus_${idx}`);
    try {
  const pagePrefix = PAGE_PREFIX || computePagePrefix();
  const sidecarKey = pagePrefix + `notes_section_${idx}.assessment.json`;
  const resp = await authedFetch(`/api/assessment?key=${encodeURIComponent(sidecarKey)}`);
      if (!resp.ok) {
        return;
      }
      const j = await resp.json().catch((error) => {
        console.warn('parse sidecar json', error);
        return null;
      });
      const item = j?.item;
      if (item && item.result && typeof item.result === 'object') {
        const r = item.result;
        if (!notesDirty) {
          if (typeof r.listening === 'string') {
            noteInput.value = r.listening;
            storageSet(`note_${idx}`, noteInput.value.trim());
          }
          if (typeof r.translation === 'string') {
            transInput.value = r.translation;
            storageSet(`trans_${idx}`, transInput.value.trim());
          }
          if (entryEl) entryEl.dataset.dirty = '0';
          notesDirty = false;
        }

        if (typeof r.pronunciationAttempts === 'number' && Number.isFinite(r.pronunciationAttempts)) {
          const current = getPronunciationAttempts(idx);
          const remoteCount = Math.max(0, Math.floor(r.pronunciationAttempts));
          if (remoteCount > current) {
            setPronunciationAttempts(idx, remoteCount);
          }
          updatePronunciationQuotaDisplay(idx);
        }

        const remoteListeningHistory = Array.isArray(r.listeningHistory) ? r.listeningHistory : [];
        const remoteTranslationHistory = Array.isArray(r.translationHistory) ? r.translationHistory : [];
        const legacyListening = (!remoteListeningHistory.length && r.listening && r.listeningFeedback)
          ? [{ input: r.listening, feedback: r.listeningFeedback, createdAt: r.savedAt || item.savedAt }]
          : [];
        const legacyTranslation = (!remoteTranslationHistory.length && r.translation && r.translationFeedback)
          ? [{ input: r.translation, feedback: r.translationFeedback, createdAt: r.savedAt || item.savedAt }]
          : [];

        const mergedListening = mergeHistoryEntries([...remoteListeningHistory, ...legacyListening], loadEvaluationHistory('listening', idx));
        if (mergedListening.length) {
          saveEvaluationHistory('listening', idx, mergedListening);
          renderEvaluationHistory('listening', idx, mergedListening);
        }

        const mergedTranslation = mergeHistoryEntries([...remoteTranslationHistory, ...legacyTranslation], loadEvaluationHistory('translation', idx));
        if (mergedTranslation.length) {
          saveEvaluationHistory('translation', idx, mergedTranslation);
          renderEvaluationHistory('translation', idx, mergedTranslation);
        }

  if (syncEl) syncEl.textContent = '';
        updatePronunciationQuotaDisplay(idx);
      }
    } catch (error) {
      console.warn('fetchRemoteNotes failed', error);
      if (syncEl) syncEl.textContent = 'Ë™≠„ÅøËæº„Åø„Å´Â§±Êïó';
    } finally {
      remoteNoteLoading = false;
      notesLoaded = true;
      updateEntrySummary(idx);
      updatePronunciationQuotaDisplay(idx);
    }
  }
  // localStorage for in-session persistence; server sync happens when section closes
  noteInput.addEventListener("input", () => {
    const v = noteInput.value.trim();
    storageSet(`note_${idx}`, v);
    notesDirty = true;
    if (entryEl) entryEl.dataset.dirty = '1';
    const syncEl = document.getElementById(`syncStatus_${idx}`);
    if (syncEl) syncEl.textContent = 'Êú™‰øùÂ≠ò (Èñâ„Åò„Çã„Å®‰øùÂ≠ò)';
    updateEntrySummary(idx);
  });
  transInput.addEventListener("input", () => {
    const v = transInput.value.trim();
    storageSet(`trans_${idx}`, v);
    notesDirty = true;
    if (entryEl) entryEl.dataset.dirty = '1';
    const syncEl = document.getElementById(`syncStatus_${idx}`);
    if (syncEl) syncEl.textContent = 'Êú™‰øùÂ≠ò (Èñâ„Åò„Çã„Å®‰øùÂ≠ò)';
    updateEntrySummary(idx);
  });
  const listeningBtn = document.getElementById(`note_${idx}_compare`);
  const translationBtn = document.getElementById(`trans_${idx}_compare`);
  if (listeningBtn) {
    listeningBtn.addEventListener('click', () =>
      callChatGPT({ type: 'listening', idx, inputEl: noteInput, referenceText: sentence, buttonEl: listeningBtn })
    );
  }
  if (translationBtn) {
    translationBtn.addEventListener('click', () =>
      callChatGPT({ type: 'translation', idx, inputEl: transInput, referenceText: sentence, buttonEl: translationBtn })
    );
  }

  // save note/translation pair to server sidecar for cross-device sync
  async function saveNotesToServer(sectionIdx) {
    if (!notesDirty) return;
    try {
      const syncEl = document.getElementById(`syncStatus_${sectionIdx}`);
      const listening = document.getElementById(`note_${sectionIdx}_input`).value.trim();
      const translation = document.getElementById(`trans_${sectionIdx}_input`).value.trim();
      const listeningHistory = loadEvaluationHistory('listening', sectionIdx);
      const translationHistory = loadEvaluationHistory('translation', sectionIdx);
      const pronunciationAttempts = getPronunciationAttempts(sectionIdx);
      if (syncEl) syncEl.textContent = '‰øùÂ≠ò‰∏≠‚Ä¶';
      updateEntrySummary(sectionIdx);

      const pagePrefix = PAGE_PREFIX;
      const body = {
        key: pagePrefix + `notes_section_${sectionIdx}`,
        result: {
          listening,
          translation,
          listeningHistory,
          translationHistory,
          pronunciationAttempts,
          savedAt: new Date().toISOString()
        },
        referenceText: ''
      };

      const resp = await authedFetch('/api/assessment', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });

      if (resp && resp.ok) {
        if (syncEl) syncEl.textContent = '‰øùÂ≠òÊ∏à„Åø';
        notesDirty = false;
        if (entryEl) entryEl.dataset.dirty = '0';
        notesLoaded = true;
      } else {
        if (syncEl) syncEl.textContent = '‰øùÂ≠ò„Å´Â§±Êïó';
        console.warn('saveNotesToServer resp not ok', resp);
        notesDirty = true;
        if (entryEl) entryEl.dataset.dirty = '1';
      }
      updateEntrySummary(sectionIdx);
    } catch (e) {
      console.warn('saveNotesToServer failed', e);
      const syncEl = document.getElementById(`syncStatus_${sectionIdx}`);
      if (syncEl) syncEl.textContent = '‰øùÂ≠ò„Å´Â§±Êïó';
      notesDirty = true;
      if (entryEl) entryEl.dataset.dirty = '1';
      updateEntrySummary(sectionIdx);
    }
  }
  if (primaryScriptBtn && primaryScriptContent) {
    primaryScriptBtn.addEventListener("click", () => {
      const isVisible = primaryScriptContent.style.display === "block";
      primaryScriptContent.style.display = isVisible ? "none" : "block";
      primaryScriptBtn.textContent = isVisible ? "üìú „Çπ„ÇØ„É™„Éó„Éà„ÇíË°®Á§∫" : "üìú „Çπ„ÇØ„É™„Éó„Éà„ÇíÈñâ„Åò„Çã";
    });
  }
  if (secondaryScriptBtn && secondaryScriptContent) {
    secondaryScriptBtn.addEventListener("click", () => {
      const isVisible = secondaryScriptContent.style.display === "block";
      secondaryScriptContent.style.display = isVisible ? "none" : "block";
      secondaryScriptBtn.textContent = isVisible ? "üìú „Çπ„ÇØ„É™„Éó„Éà„ÇíË°®Á§∫" : "üìú „Çπ„ÇØ„É™„Éó„Éà„ÇíÈñâ„Åò„Çã";
    });
  }

  let lastRecordedFile = null;
  const resultBox = document.getElementById(`result_${idx}`);
  const recStatus = document.getElementById(`recStatus_${idx}`);

  updatePronunciationQuotaDisplay(idx);

  function disposePendingPreview() {
    if (pendingPreview) {
      pendingPreview.innerHTML = '';
      pendingPreview.style.display = 'none';
    }
    if (pendingPreviewUrl) {
      URL.revokeObjectURL(pendingPreviewUrl);
      pendingPreviewUrl = null;
    }
  }

  function deletePendingRecording() {
    disposePendingPreview();
    lastRecordedFile = null;
    if (submitBtn) submitBtn.disabled = true;
    if (recStatus) recStatus.textContent = '';
  resultBox.textContent = 'Èå≤Èü≥„Éó„É¨„Éì„É•„Éº„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü„ÄÇ';
    if (recToggleBtn) {
      recToggleBtn.dataset.state = 'idle';
      recToggleBtn.textContent = 'üéôÔ∏è Èå≤Èü≥ÈñãÂßã';
      recToggleBtn.classList.remove('recording');
    }
    updateEntrySummary(idx);
  }

  function showPendingPreview(file, url) {
    if (!pendingPreview) {
      URL.revokeObjectURL(url);
      return;
    }
    disposePendingPreview();
    pendingPreview.innerHTML = `
      <div class="pending-preview-header">Èå≤Èü≥„Éó„É¨„Éì„É•„Éº</div>
      <div class="pending-preview-row">
        <audio controls src="${url}"></audio>
        <button type="button" class="pending-preview-delete">„Éó„É¨„Éì„É•„ÉºÂâäÈô§</button>
      </div>
    `;
    pendingPreview.style.display = 'block';
    pendingPreviewUrl = url;
    const deleteBtn = pendingPreview.querySelector('.pending-preview-delete');
    if (deleteBtn) deleteBtn.addEventListener('click', deletePendingRecording);
  }
  // Áô∫Èü≥Ë©ï‰æ°: Èå≤Èü≥ or „Éï„Ç°„Ç§„É´ÈÅ∏Êäû -> S3„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ -> Azure Ë©ï‰æ° -> „Çµ„Ç§„Éâ„Ç´„Éº‰øùÂ≠ò -> Ë°®Á§∫
  const API_UPLOAD = '/api/upload';
  const API_ASSESS = '/api/azure-assess';
  const API_ASSESS_SAVE = '/api/assessment';

  async function fetchAssessmentsForSection(force = false) {
    if (assessmentLoading) return;
    if (assessmentsLoaded && !force) return;
    assessmentLoading = true;
    const prefix = PAGE_PREFIX + `section_${idx}/`;
    try {
  const upl = await authedFetch('/api/upload?prefix=' + encodeURIComponent(prefix));
      if (!upl.ok) return;
      const ju = await upl.json().catch(() => null);
      if (!ju || !Array.isArray(ju.items)) return;
      const collected = [];
      for (const it of ju.items) {
        const key = it.key;
        if (!key) continue;
        try {
          let fileUrl = it.presignedUrl || it.url || null;
          if (!fileUrl) {
            const info = await authedFetch('/api/upload?key=' + encodeURIComponent(key));
            if (info.ok) {
              const infoJson = await info.json().catch(() => null);
              fileUrl = infoJson?.item?.presignedUrl || infoJson?.item?.url || fileUrl;
            }
          }
          addRecordingCard(idx, { key, url: fileUrl, fileName: key.split('/').pop(), size: it.size || 0, lastModified: it.lastModified || it.LastModified });
          const assessResp = await authedFetch('/api/assessment?key=' + encodeURIComponent(key + '.assessment.json'));
          if (!assessResp.ok) continue;
          const detail = await assessResp.json().catch(() => null);
          const payload = detail?.item;
          const result = payload?.result || null;
          if (!result) continue;
          let ts = null;
          if (payload && payload.savedAt) ts = Date.parse(payload.savedAt);
          else if (it.lastModified) ts = (new Date(it.lastModified)).getTime();
          else ts = Date.now();
          collected.push({ key, result, ts });
          const savedAt = payload?.savedAt || payload?.result?.savedAt || it.lastModified || it.LastModified;
          markCardAssessed(idx, key, result, savedAt);
        } catch (error) {
          console.warn('fetchAssessmentsForSection item failed', error);
        }
      }
      if (collected.length) {
        const latest = collected.sort((a, b) => (b.ts || 0) - (a.ts || 0))[0];
        if (latest) {
          displayResults(JSON.stringify(latest.result), idx);
        }
        const assessedTotal = collected.length;
        const currentAttempts = getPronunciationAttempts(idx);
        if (assessedTotal > currentAttempts) {
          setPronunciationAttempts(idx, assessedTotal);
        }
        updatePronunciationQuotaDisplay(idx);
      }
    } catch (error) {
      console.warn('fetchAssessmentsForSection failed', error);
    } finally {
      assessmentLoading = false;
      assessmentsLoaded = true;
      updateEntrySummary(idx);
      updatePronunciationQuotaDisplay(idx);
    }
  }

  // no file input: only recorded files are supported

  // recorder per-section (uses AudioWorklet if available)
  let _recorder = null; // storing state per section in closure
  async function startRecordingForSection(){
    if (recToggleBtn) {
      recToggleBtn.disabled = true;
    }
    if (submitBtn) submitBtn.disabled = true;
    disposePendingPreview();
    lastRecordedFile = null;
    if (recStatus) recStatus.textContent = '';
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const ac = new (window.AudioContext||window.webkitAudioContext)({ sampleRate: 16000 });
      try { if (ac.state === 'suspended') await ac.resume(); } catch {}
      await ac.audioWorklet.addModule('./audio-recording/audio-processor.js');
      const src = ac.createMediaStreamSource(stream);
      const node = new AudioWorkletNode(ac, 'audio-processor');
      const mute = ac.createGain(); mute.gain.value = 0;
      const chunks = [];
      node.port.onmessage = ev => chunks.push(new Float32Array(ev.data));
      src.connect(node); node.connect(mute).connect(ac.destination);
  _recorder = { ac, stream, node, mute, chunks, startedAt: performance.now(), timerId: null };
      // start timer display
      try{
        const timerEl = document.getElementById(`recTimer_${idx}`);
        const start = performance.now();
        _recorder.timerId = setInterval(()=>{
          const s = Math.floor((performance.now()-start)/1000);
          const mm = String(Math.floor(s/60)).padStart(2,'0');
          const ss = String(s%60).padStart(2,'0');
          if (timerEl) timerEl.textContent = `${mm}:${ss}`;
        }, 250);
      }catch(e){}
      if (recStatus) recStatus.textContent = 'Èå≤Èü≥‰∏≠';
      if (recToggleBtn) {
        recToggleBtn.dataset.state = 'recording';
        recToggleBtn.textContent = '‚èπÔ∏è Èå≤Èü≥ÂÅúÊ≠¢';
        recToggleBtn.classList.add('recording');
      }
      if (resultBox) resultBox.textContent = '';
    } catch(e){
      if (resultBox) resultBox.textContent = 'Èå≤Èü≥ÈñãÂßãÂ§±Êïó: '+e.message;
      _recorder = null;
      if (recToggleBtn) {
        recToggleBtn.dataset.state = 'idle';
        recToggleBtn.textContent = 'üéôÔ∏è Èå≤Èü≥ÈñãÂßã';
        recToggleBtn.classList.remove('recording');
      }
    } finally {
      if (recToggleBtn) recToggleBtn.disabled = false;
    }
  }

  async function stopRecordingForSection(){
    if (!_recorder) return;
    const recorderRef = _recorder;
    if (recToggleBtn) recToggleBtn.disabled = true;
    try {
      const { stream, node, mute, chunks } = recorderRef;
      try { node && node.disconnect(); } catch {}
      try { mute && mute.disconnect(); } catch {}
      try { stream && stream.getTracks().forEach(t=>t.stop()); } catch {}
      const total = chunks.reduce((s,a)=> s + a.length, 0);
      const buf = new Float32Array(total);
      let off = 0; for (const a of chunks){ buf.set(a, off); off += a.length; }
      // resample if necessary (recorderRef.ac.sampleRate -> 16000 assumed)
      const effective = recorderRef.ac.sampleRate || 16000;
      let out = buf;
      if (Math.abs(effective - 16000) > 1) out = resampleLinear(buf, effective, 16000);
      const wav = encodeWavFromFloat32(out, 16000);
      const blob = new Blob([wav], { type: 'audio/wav' });
      // attach blob to file input (so UI still uses fileInput.files if needed)
      const file = new File([blob], `rec_${Date.now()}.wav`, { type: 'audio/wav' });
      lastRecordedFile = file;
      const previewUrl = URL.createObjectURL(blob);
      showPendingPreview(file, previewUrl);
      if (resultBox) resultBox.textContent = '';
      if (recStatus) recStatus.textContent = 'Èå≤Èü≥ÂÆå‰∫Ü';
      // stop timer and enable submit
    try{ if (recorderRef.timerId) clearInterval(recorderRef.timerId); const tEl = document.getElementById(`recTimer_${idx}`); if (tEl) tEl.textContent = ''; }catch(e){}
    const limitReached = isPronunciationLimitReached(idx);
    if (submitBtn) submitBtn.disabled = limitReached;
    if (limitReached) {
      setPronunciationLimitMessage(recStatus);
    }
    updatePronunciationQuotaDisplay(idx);
    } catch(e){
      resultBox.textContent = 'Èå≤Èü≥ÂÅúÊ≠¢„Ç®„É©„Éº: '+e.message;
    } finally {
      try { await recorderRef.ac.close(); } catch {}
      _recorder = null;
      if (recToggleBtn) {
        recToggleBtn.disabled = false;
        recToggleBtn.dataset.state = 'idle';
        recToggleBtn.textContent = 'üéôÔ∏è Èå≤Èü≥ÈñãÂßã';
        recToggleBtn.classList.remove('recording');
      }
      updatePronunciationQuotaDisplay(idx);
    }
  }

  if (recToggleBtn) {
    let toggleBusy = false;
  recToggleBtn.dataset.state = 'idle';
  recToggleBtn.classList.remove('recording');
  recToggleBtn.textContent = 'üéôÔ∏è Èå≤Èü≥ÈñãÂßã';
    recToggleBtn.addEventListener('click', async () => {
      if (toggleBusy) return;
      toggleBusy = true;
      try {
        if (_recorder) {
          await stopRecordingForSection();
        } else {
          await startRecordingForSection();
        }
      } finally {
        toggleBusy = false;
      }
    });
  }
  // move the submit button into the same row as the recording controls for better UX
  try{
    if (recToggleBtn && submitBtn && recToggleBtn.parentNode && !recToggleBtn.parentNode.contains(submitBtn)){
      submitBtn.style.marginLeft = '8px';
      recToggleBtn.parentNode.appendChild(submitBtn);
    }
  }catch(e){}

  // helper: encode/resample functions (from integrated file)
  function resampleLinear(data, src, dst){ if (src === dst) return data; const ratio = src / dst, N = Math.round(data.length / ratio); const out = new Float32Array(N); for (let i=0;i<N;i++){ const p = i * ratio, i0 = Math.floor(p), i1 = Math.min(i0+1, data.length-1), t = p - i0; out[i] = data[i0]*(1-t) + data[i1]*t; } return out; }
  function encodeWavFromFloat32(ch, sr){ const len = ch.length, buf = new ArrayBuffer(44 + len*2), v = new DataView(buf); const w = (s,o)=>{ for(let i=0;i<s.length;i++) v.setUint8(o+i,s.charCodeAt(i)); }; let p=0; w('RIFF',p); p+=4; v.setUint32(p,36+len*2,true); p+=4; w('WAVE',p); p+=4; w('fmt ',p); p+=4; v.setUint32(p,16,true); p+=4; v.setUint16(p,1,true); p+=2; v.setUint16(p,1,true); p+=2; v.setUint32(p,sr,true); p+=4; v.setUint32(p,sr*2,true); p+=4; v.setUint16(p,2,true); p+=2; v.setUint16(p,16,true); p+=2; w('data',p); p+=4; v.setUint32(p,len*2,true); p+=4; for(let i=0;i<len;i++){ const s=Math.max(-1,Math.min(1,ch[i])); v.setInt16(p, s<0? s*0x8000 : s*0x7FFF, true); p+=2; } return buf; }
  function fmtBytes(b){ if (!b) return ''; if (b<1024) return b+'B'; if (b<1024*1024) return (b/1024).toFixed(1)+'KB'; return (b/1024/1024).toFixed(2)+'MB'; }

  // upload blob/file to /api/upload with prefix per section
  async function uploadFileAndAssess(fileBlob){
    resultBox.textContent = '„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠...';
    if (isGlobalQuotaExhausted('pronunciation')) {
      setPronunciationLimitMessage(recStatus);
      updatePronunciationQuotaDisplay(idx);
      resultBox.textContent = 'AIÂà©Áî®ÂõûÊï∞„ÅÆ‰∏äÈôê„Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ';
      if (submitBtn) submitBtn.disabled = true;
      return;
    }
    const fd = new FormData();
    fd.append('file', new File([fileBlob], fileBlob.name || `rec_${Date.now()}.wav`, { type: fileBlob.type || 'audio/wav' }));
    const prefix = PAGE_PREFIX + `section_${idx}/`;
    fd.append('prefix', prefix);
    let uploadResp;
    try {
      // disable submit during upload/assess
      if (submitBtn) submitBtn.disabled = true;
  uploadResp = await authedFetch(API_UPLOAD, { method:'POST', body: fd });
      if (!uploadResp.ok) {
        let detail = '';
        try {
          const errText = await uploadResp.text();
          if (errText) {
            try {
              const parsed = JSON.parse(errText);
              detail = parsed.detail || parsed.error || errText;
            } catch {
              detail = errText;
            }
          }
        } catch {}
        const message = detail ? `upload failed ${uploadResp.status}: ${detail}` : `upload failed ${uploadResp.status}`;
        throw new Error(message);
      }
      const upj = await uploadResp.json();
      const audioUrl = upj.presignedUrl || upj.url;
      const s3Key = upj.key;
      // add recording card to the UI for this section
  const nowIso = new Date().toISOString();
  try { addRecordingCard(idx, { key: s3Key, url: audioUrl, fileName: fileBlob.name || ('rec_'+Date.now()+'.wav'), size: fileBlob.size || 0, lastModified: nowIso }); } catch(e){ console.warn('addRecordingCard failed', e); }
  resultBox.textContent = '„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆå‰∫Ü„ÄÇË©ï‰æ°‰∏≠‚Ä¶';
      // call azure-assess
    const referenceText = sentence;
      try {
        await reserveQuotaUsage('pronunciation');
      } catch (quotaErr) {
        setPronunciationLimitMessage(recStatus);
        updatePronunciationQuotaDisplay(idx);
        if (quotaErr instanceof QuotaError) {
          throw new Error('AIÂà©Áî®ÂõûÊï∞„ÅÆ‰∏äÈôê„Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ');
        }
        throw quotaErr;
      }
      updatePronunciationQuotaDisplay(idx);
      const assessResp = await authedFetch(API_ASSESS, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ audioUrl, referenceText, language: 'en-US' }) });
      if (!assessResp.ok) { const t = await assessResp.text(); throw new Error('azure-assess failed: '+assessResp.status+' '+t); }
      const assessJson = await assessResp.json();
      // save assessment sidecar: key should be s3Key
  const saveResp = await authedFetch(API_ASSESS_SAVE, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ key: s3Key, result: assessJson, referenceText }) });
      if (!saveResp.ok) { const t = await saveResp.text(); throw new Error('save assessment failed: '+saveResp.status+' '+t); }
      resultBox.textContent = 'Ë©ï‰æ°ÂÆå‰∫Ü„Éª‰øùÂ≠òÊ∏à„Åø';
      // render results
    // update card with assessment marker and also render main area
  try { markCardAssessed(idx, s3Key, assessJson, nowIso); } catch(e){}
    displayResults(JSON.stringify(assessJson.result || assessJson?.result || assessJson), idx);
      const attempts = incrementPronunciationAttempts(idx);
      updatePronunciationQuotaDisplay(idx);
      try {
        const listeningVal = document.getElementById(`note_${idx}_input`)?.value.trim() || '';
        const translationVal = document.getElementById(`trans_${idx}_input`)?.value.trim() || '';
        const listeningHistory = loadEvaluationHistory('listening', idx);
        const translationHistory = loadEvaluationHistory('translation', idx);
        const pageKeyPrefix = PAGE_PREFIX || computePagePrefix();
        authedFetch('/api/assessment', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            key: pageKeyPrefix + `notes_section_${idx}`,
            result: {
              listening: listeningVal,
              translation: translationVal,
              listeningHistory,
              translationHistory,
              pronunciationAttempts: attempts,
              savedAt: new Date().toISOString()
            },
            referenceText: ''
          })
        }).catch(err => console.warn('persist pronunciation attempts failed', err));
      } catch (metaErr) {
        console.warn('collect pronunciation metadata failed', metaErr);
      }
      disposePendingPreview();
      lastRecordedFile = null;
      if (recStatus) recStatus.textContent = '„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÊ∏à„Åø (Èå≤Èü≥‰∏ÄË¶ß„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ)';
    } catch(e){
      resultBox.textContent = '„Ç®„É©„Éº: '+e.message;
    } finally {
      const limitReached = isPronunciationLimitReached(idx);
      if (submitBtn) submitBtn.disabled = limitReached || !lastRecordedFile;
      if (limitReached) {
        setPronunciationLimitMessage(recStatus);
      }
      updatePronunciationQuotaDisplay(idx);
    }
    updateEntrySummary(idx);
  }

  // submit handler (file input must contain .wav or recording filled into fileInput)
  if (submitBtn) submitBtn.onclick = async () => {
    resultBox.textContent = '';
    if (!lastRecordedFile) { resultBox.textContent = 'Èå≤Èü≥„ÇíË°å„Å£„Å¶„Åã„Çâ„ÄåÁô∫Èü≥Ë©ï‰æ°„ÇíÂÆüË°å„Äç„ÇíÊäº„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'; return; }
    if (isPronunciationLimitReached(idx)) {
      if (isGlobalQuotaExhausted('pronunciation')) {
        alert('AIÂà©Áî®ÂõûÊï∞„ÅÆ‰∏äÈôê„Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ');
      } else if (Number.isFinite(sectionLimits.pronunciation)) {
        alert(`Áô∫Èü≥Ë©ï‰æ°„ÅØ1„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Å§„Åç${sectionLimits.pronunciation}Âõû„Åæ„Åß„Åß„Åô„ÄÇ`);
      }
      if (submitBtn) submitBtn.disabled = true;
      setPronunciationLimitMessage(recStatus);
      updatePronunciationQuotaDisplay(idx);
      return;
    }
    await uploadFileAndAssess(lastRecordedFile);
  };

  if (submitBtn && isPronunciationLimitReached(idx)) {
    submitBtn.disabled = true;
    setPronunciationLimitMessage(recStatus);
    updatePronunciationQuotaDisplay(idx);
  }

  // page-level word toggle removed; per-card controls are used instead
}

// ChatGPTÈÄ£Êê∫ÔºàÊó•Êú¨Ë™û„Éó„É≠„É≥„Éó„ÉàÔºâ
async function callChatGPT({ type, idx, inputEl, referenceText, buttonEl }) {
  const isTranslation = type === 'translation';
  const quotaType = isTranslation ? 'translation' : 'listening';
  const textValue = inputEl?.value ?? '';
  const userText = String(textValue).trim();
  if (!userText) {
    if (inputEl) inputEl.focus();
    return;
  }

  if (isGlobalQuotaExhausted(quotaType)) {
    alert('AIÂà©Áî®ÂõûÊï∞„ÅÆ‰∏äÈôê„Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ');
    updateEvaluationQuotaDisplay(quotaType, idx);
    return;
  }

  const localLimit = isTranslation ? sectionLimits.translation : sectionLimits.listening;
  if (Number.isFinite(localLimit)) {
    const existing = getEvaluationAttempts(quotaType, idx);
    if (existing >= Math.floor(localLimit)) {
      const label = isTranslation ? 'ÁøªË®≥Ë©ï‰æ°' : 'ËÅû„ÅçÂèñ„ÇäË©ï‰æ°';
      alert(`${label}„ÅØ1„Çª„ÇØ„Ç∑„Éß„É≥„Å´„Å§„Åç${localLimit}Âõû„Åæ„Åß„Åß„Åô„ÄÇ`);
      updateEvaluationQuotaDisplay(quotaType, idx);
      return;
    }
  }

  const prompt = isTranslation
    ? {
        system: "„ÅÇ„Å™„Åü„ÅØÊó•Ëã±ÁøªË®≥„ÇíÊé°ÁÇπ„Åô„ÇãË¨õÂ∏´„Åß„Åô„ÄÇÂ≠¶ÁøíËÄÖ„ÅÆÂíåË®≥„Çí100ÁÇπÊ∫ÄÁÇπ„ÅßË©ï‰æ°„Åó„ÄÅÊîπÂñÑÁÇπ„ÇíÊó•Êú¨Ë™û„Åß‰∏ÅÂØß„Å´Ë™¨Êòé„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇË©ï‰æ°„ÅØJSON„Å†„Åë„ÅßËøî„Åó„ÄÅscore(Êï¥Êï∞0-100)„Å®feedback(Êó•Êú¨Ë™û„Ç≥„É°„É≥„Éà)„ÅÆ2„Å§„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£„ÇíÂê´„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        template: "Â≠¶ÁøíËÄÖ„ÅÆË®≥: {{student}}\nÂéüÊñá: {{reference}}\n\nÊ¨°„ÅÆJSONÂΩ¢Âºè„ÅÆ„Åø„ÅßÂõûÁ≠î„Åó„Å¶„Åè„Å†„Åï„ÅÑ:\n{\"score\": <0„Åã„Çâ100„ÅÆÊï¥Êï∞>, \"feedback\": \"Êó•Êú¨Ë™û„Ç≥„É°„É≥„Éà\"}"
      }
    : {
        system: "„ÅÇ„Å™„Åü„ÅØËã±Ë™û„É™„Çπ„Éã„É≥„Ç∞„ÇíÊåáÂ∞é„Åô„ÇãË¨õÂ∏´„Åß„Åô„ÄÇÂ≠¶ÁøíËÄÖ„ÅåËÅû„ÅçÂèñ„Å£„ÅüËã±Êñá„Å®ÂÖ¨Âºè„Çπ„ÇØ„É™„Éó„Éà„Çí‰∏ÅÂØß„Å´ÊØîËºÉ„Åó„ÄÅÊ≠£Á¢∫„Åï„Çí100ÁÇπÊ∫ÄÁÇπ„ÅßÊé°ÁÇπ„Åó„Å¶„ÄÅÊó•Êú¨Ë™û„ÅßËÇØÂÆöÁöÑ„Åã„Å§ÂÖ∑‰ΩìÁöÑ„Å™ÊîπÂñÑ„Ç≥„É°„É≥„Éà„ÇíËøî„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÂá∫Âäõ„ÅØJSON„ÅÆ„Åø„Åß„ÄÅscore(Êï¥Êï∞0-100)„Å®feedback(Êó•Êú¨Ë™û„Ç≥„É°„É≥„Éà)„ÇíÂê´„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        template: "Â≠¶ÁøíËÄÖ„ÅåËÅû„ÅçÂèñ„Å£„Å¶ÂÖ•Âäõ„Åó„ÅüËã±Êñá:\n{{student}}\n\nÂÖ¨Âºè„ÅÆÊ≠£„Åó„ÅÑ„Çπ„ÇØ„É™„Éó„Éà:\n{{reference}}\n\nÊ¨°„ÅÆJSONÂΩ¢Âºè„Å†„Åë„ÅßÂõûÁ≠î„Åó„Å¶„Åè„Å†„Åï„ÅÑ:\n{\"score\": <0„Åã„Çâ100„ÅÆÊï¥Êï∞>, \"feedback\": \"Êó•Êú¨Ë™û„Ç≥„É°„É≥„Éà\"}"
      };

  const originalLabel = buttonEl?.textContent;
  if (buttonEl) {
    buttonEl.disabled = true;
    buttonEl.textContent = 'Ë©ï‰æ°‰∏≠‚Ä¶';
  }

  try {
    await reserveQuotaUsage(quotaType);
    const systemPrompt = prompt.system;
    const userPrompt = prompt.template.replace("{{student}}", userText).replace("{{reference}}", referenceText);
    const body = { model: 'gpt-4', messages: [ { role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt } ] };
    const res = await authedFetch('/api/chat', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
    if (!res.ok) throw new Error(`Error: ${res.status} ${res.statusText}`);
    const data = await res.json();
    const rawContent = data.choices?.[0]?.message?.content || '';
    const parsed = parseEvaluationScorePayload(rawContent);
    const feedback = parsed.feedback || '‚ö†Ô∏è ÂøúÁ≠î„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ';
    const score = parsed.score;

    const evalType = isTranslation ? 'translation' : 'listening';
    incrementEvaluationAttempts(evalType, idx);
    appendEvaluationHistory(evalType, idx, userText, feedback, score);

  const legacyKey = isTranslation ? `chatResponse_translation_${idx}` : `chatResponse_listening_${idx}`;
  storageRemove(legacyKey);

    if (inputEl) {
      inputEl.value = '';
      const storageKey = isTranslation ? `trans_${idx}` : `note_${idx}`;
      storageRemove(storageKey);
    }

    const listening = document.getElementById(`note_${idx}_input`)?.value.trim() || '';
    const translation = document.getElementById(`trans_${idx}_input`)?.value.trim() || '';
    const listeningHistory = loadEvaluationHistory('listening', idx);
    const translationHistory = loadEvaluationHistory('translation', idx);
    const pronunciationAttempts = getPronunciationAttempts(idx);

    const pageKeyPrefix = PAGE_PREFIX || computePagePrefix();
    authedFetch('/api/assessment', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        key: pageKeyPrefix + `notes_section_${idx}`,
        result: {
          listening,
          translation,
          listeningHistory,
          translationHistory,
          pronunciationAttempts,
          savedAt: new Date().toISOString()
        },
        referenceText: ''
      })
    }).catch(e => console.warn('persist chat feedback failed', e));

    const entryEl = document.querySelector(`.entry[data-section="${idx}"]`);
    if (entryEl) entryEl.dataset.dirty = '0';
    const syncEl = document.getElementById(`syncStatus_${idx}`);
    if (syncEl) syncEl.textContent = '‰øùÂ≠òÊ∏à„Åø';
    updateEvaluationQuotaDisplay(quotaType, idx);
  } catch (e) {
    if (e instanceof QuotaError) {
      alert('AIÂà©Áî®ÂõûÊï∞„ÅÆ‰∏äÈôê„Å´ÈÅî„Åó„Åæ„Åó„Åü„ÄÇ');
      updateEvaluationQuotaDisplay(quotaType, idx);
    } else {
      console.warn('callChatGPT failed', e);
      alert(`Ë©ï‰æ°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ${e.message}`);
    }
  } finally {
    if (buttonEl) {
      buttonEl.disabled = false;
      buttonEl.textContent = originalLabel || (isTranslation ? 'ÁøªË®≥Ë©ï‰æ°' : '„É™„Çπ„Éã„É≥„Ç∞Ë©ï‰æ°');
    }
    updateEntrySummary(idx);
  }
}

function displayResults(jsonString, idx) {
  // make function tolerant to multiple Azure response shapes
  let data;
  try { data = (typeof jsonString === 'string') ? JSON.parse(jsonString) : jsonString; } catch (e) { data = jsonString; }

  // normalize: try a few common nesting patterns where the actual NBest may live
  const pickNested = (obj) => {
    if (!obj || typeof obj !== 'object') return null;
    if (Array.isArray(obj.NBest) && obj.NBest.length) return obj;
    if (obj.result && Array.isArray(obj.result.NBest) && obj.result.NBest.length) return obj.result;
    if (obj.result && obj.result.result && Array.isArray(obj.result.result.NBest) && obj.result.result.NBest.length) return obj.result.result;
    // sometimes the payload itself is the NBest entry
    if (Array.isArray(obj) && obj.length && obj[0].Words) return { NBest: obj };
    return obj;
  };

  const normalized = pickNested(data) || data;
  // prefer first NBest entry; if missing, fallback to 'result' object
  const nb = (Array.isArray(normalized.NBest) && normalized.NBest[0]) || normalized.NBest || normalized.result || normalized;

  // PronunciationAssessment may be nested or flattened
  const pa = nb.PronunciationAssessment || nb;
  const score = pa.PronScore ?? pa.PronunciationScore ?? pa.Pron ?? pa.PronunciationScore ?? null;
  const accuracy = pa.AccuracyScore ?? pa.AccScore ?? nb.AccuracyScore ?? nb.AccScore ?? null;
  const fluency = pa.FluencyScore ?? pa.FluScore ?? nb.FluencyScore ?? nb.FluScore ?? null;
  const completeness = pa.CompletenessScore ?? pa.CompScore ?? nb.CompletenessScore ?? nb.CompScore ?? null;
  const words = nb.Words || pa.Words || [];

  // main numeric score and subscores intentionally omitted ‚Äî per-card UI shows word-level details
  const scoreEl = document.getElementById(`scoreBlock_${idx}`);
  if (scoreEl) scoreEl.innerHTML = '';
  // also hide/clear the page-level words block to avoid duplicate information
  const wordsMain = document.getElementById(`wordsBlock_${idx}`);
  if (wordsMain) { wordsMain.style.display = 'none'; const tb = wordsMain.querySelector('tbody'); if (tb) tb.innerHTML = ''; }
  // done ‚Äî per-card rendering handled elsewhere
  return;
  // page-level words display intentionally suppressed; details shown on recording cards
}

// ===== persistence: load saved recordings & assessments for this page =====
// small utility: format bytes -> human readable
function fmtBytes(b){
  if (!b && b !== 0) return '';
  if (b < 1024) return b + 'B';
  if (b < 1024 * 1024) return (b / 1024).toFixed(1) + 'KB';
  return (b / 1024 / 1024).toFixed(2) + 'MB';
}

function formatRelativeTime(ts){
  if (!ts) return '';
  const date = (ts instanceof Date) ? ts : new Date(ts);
  if (Number.isNaN(date.getTime())) return '';
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const minutes = Math.floor(diffMs / 60000);
  const hours = Math.floor(diffMs / 3600000);
  const days = Math.floor(diffMs / 86400000);
  if (diffMs < 0) return 'Êú™Êù•„ÅÆÈå≤Èü≥';
  if (minutes < 1) return '„Åü„Å£„Åü‰ªä';
  if (minutes < 60) return `${minutes}ÂàÜÂâç`;
  if (hours < 24 && now.toDateString() === date.toDateString()) return `${hours}ÊôÇÈñìÂâç`;
  if (days === 1) return '1Êó•Ââç';
  if (days < 7) return `${days}Êó•Ââç`;
  return date.toLocaleString();
}

function setCardTimestamp(card, ts){
  if (!card) return;
  const date = ts ? new Date(ts) : null;
  if (!date || Number.isNaN(date.getTime())) return;
  card.dataset.lastModified = date.toISOString();
  const tsEl = card.querySelector('.rec-timestamp');
  if (tsEl) tsEl.textContent = formatRelativeTime(date);
}

function reorderRecordingList(listEl){
  if (!listEl) return;
  const cards = Array.from(listEl.children);
  cards.sort((a, b) => {
    const ta = new Date(a.dataset?.lastModified || 0).getTime();
    const tb = new Date(b.dataset?.lastModified || 0).getTime();
    return tb - ta;
  });
  cards.forEach(card => listEl.appendChild(card));
}
// create a small card element in the per-section recList to represent one recording
function addRecordingCard(sectionIdx, meta){
  try{
    const listEl = document.getElementById(`recList_${sectionIdx}`);
    if (!listEl) return;
    // avoid duplicate card for same key
    if (meta && meta.key){
      if (listEl.querySelector(`[data-s3key="${meta.key}"]`)) return;
    }
    const wrapper = document.createElement('div');
    wrapper.className = 'rec-card';
    if (meta && meta.key) wrapper.setAttribute('data-s3key', meta.key);
  if (meta && meta.lastModified) wrapper.dataset.lastModified = String(meta.lastModified);

    // left: circular score canvas
  const left = document.createElement('div'); left.className = 'left';
  left.style = 'display:flex;align-items:center;gap:10px;';
  const canvas = document.createElement('canvas'); canvas.width = 80; canvas.height = 80; canvas.style.width = '72px'; canvas.style.height = '72px';
  const toggleWordsBtn = document.createElement('button');
  toggleWordsBtn.textContent = 'ÂçòË™ûË©ï‰æ°„ÇíË¶ã„Çã';
  toggleWordsBtn.className = 'toggle-words-btn';
  toggleWordsBtn.disabled = true;
  toggleWordsBtn.title = '„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®ÂçòË™û„Åî„Å®„ÅÆË©ï‰æ°Ë°®„ÅåÈñã„Åç„Åæ„Åô';
  toggleWordsBtn.style = 'min-width:72px;';
  left.appendChild(canvas);
  left.appendChild(toggleWordsBtn);

    // right: inline row with audio + controls (donut, audio, buttons on one line)
    const right = document.createElement('div'); right.className = 'right';
    const inlineRow = document.createElement('div'); inlineRow.style = 'display:flex;align-items:center;gap:8px;';
    // audio element (shortened to fit)
    let a = null;
    if (meta.url){
      a = document.createElement('audio'); a.controls = true; a.src = meta.url;
      // allow audio control to flex/grow to fill remaining horizontal space
      a.style.flex = '1 1 auto'; a.style.width = 'auto'; a.style.maxWidth = 'none'; a.style.minWidth = '140px'; a.style.display = 'block';
    } else {
      a = document.createElement('div'); a.textContent = 'ÔºàÈü≥Â£∞„Å™„ÅóÔºâ'; a.style.color = '#666';
    }
    const audioWrap = document.createElement('div');
    audioWrap.style = 'display:flex;align-items:center;gap:4px;flex:1 1 auto;min-width:0;';
    audioWrap.appendChild(a);
    const timestampEl = document.createElement('span');
    timestampEl.className = 'rec-timestamp';
    timestampEl.style = 'font-size:0.85rem;color:#6b7280;white-space:nowrap;flex:0 0 auto;';
    audioWrap.appendChild(timestampEl);
  const controls = document.createElement('div'); controls.style = 'display:flex;gap:8px;align-items:center;flex:0 0 auto;';
  const delBtn = document.createElement('button'); delBtn.textContent = 'Èå≤Èü≥ÂâäÈô§'; delBtn.style.background = '#e53e3e';
    controls.appendChild(delBtn);
    inlineRow.appendChild(audioWrap); inlineRow.appendChild(controls);
    right.appendChild(inlineRow);

  const summary = document.createElement('div'); summary.className = 'rec-summary'; summary.style = 'margin-top:6px;color:#333;font-size:0.95rem;'; summary.innerHTML = '';
  right.appendChild(summary);

    // word-level table (hidden initially)
    const wordsContainer = document.createElement('div'); wordsContainer.className = 'word-table'; wordsContainer.style.display = 'none';
    wordsContainer.innerHTML = `<div class="word-table-hint">„ÇØ„É™„ÉÉ„ÇØ„Åó„ÅüÂçòË™û„Éú„Çø„É≥„ÅßË©≥Á¥∞„Å™ÂçòË™ûË©ï‰æ°„ÅåÂ±ïÈñã„Åï„Çå„Åæ„Åô„ÄÇ</div><table style="width:100%;border-collapse:collapse;"><thead><tr><th>ÂçòË™û</th><th>„Çπ„Ç≥„Ç¢</th><th>Âà§ÂÆö</th></tr></thead><tbody></tbody></table>`;
    right.appendChild(wordsContainer);

    // wire up buttons
    delBtn.onclick = async ()=>{
      if (!meta.key) { wrapper.remove(); updateEntrySummary(sectionIdx); return; }
    if (!confirm('„Åì„ÅÆÈå≤Èü≥„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) return;
  const resp = await authedFetch('/api/upload?key=' + encodeURIComponent(meta.key), { method: 'DELETE' });
    if (resp.ok) { wrapper.remove(); updateEntrySummary(sectionIdx); } else { alert('Èå≤Èü≥ÂâäÈô§„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'); }
    };
    toggleWordsBtn.onclick = ()=>{
      try{
        const wc = wrapper.querySelector('.word-table');
        if (!wc) return;
        if (wc.style.display === 'none' || wc.style.display === ''){ wc.style.display = 'block'; toggleWordsBtn.textContent = 'ÂçòË™ûË©ï‰æ°„ÇíÈö†„Åô'; }
        else { wc.style.display = 'none'; toggleWordsBtn.textContent = 'ÂçòË™ûË©ï‰æ°„ÇíË¶ã„Çã'; }
      }catch(e){ console.warn('toggleWordsBtn', e); }
    };

    wrapper.appendChild(left);
    wrapper.appendChild(right);
    listEl.appendChild(wrapper);
    const tsIso = (() => {
      if (meta && meta.lastModified) {
        const dt = new Date(meta.lastModified);
        if (!Number.isNaN(dt.getTime())) return dt.toISOString();
      }
      return new Date().toISOString();
    })();
    setCardTimestamp(wrapper, tsIso);
    reorderRecordingList(listEl);
    updateEntrySummary(sectionIdx);
    // ensure only our donut canvas remains in the card (remove stray canvases)
    canvas.classList.add('rec-donut');
    const allCanvases = wrapper.querySelectorAll('canvas');
    allCanvases.forEach(c => { if (!c.classList.contains('rec-donut')) c.remove(); });
    // draw initial placeholder donut
    drawDonutOnCanvas(canvas, null);
  }catch(e){ console.warn('addRecordingCard error', e); }
}

// mark an existing card as assessed and attach short summary (and store full result on element)
function markCardAssessed(sectionIdx, s3Key, assessJson, savedAt){
  try{
    const listEl = document.getElementById(`recList_${sectionIdx}`); if (!listEl) return;
    const card = listEl.querySelector(`[data-s3key="${s3Key}"]`);
    if (!card) return;
    card.dataset.assessed = 'true';
    const summary = card.querySelector('div');
    // try to pull a numeric score
  const nb = (assessJson && (assessJson.result || assessJson))?.result || assessJson?.result || assessJson;
    // find first score value tolerant
    let score = null;
    try {
      const s = (assessJson?.result?.NBest?.[0]) || (assessJson?.NBest?.[0]) || assessJson;
      const rawScore = s?.PronunciationAssessment?.PronScore ?? s?.PronScore ?? s?.PronunciationScore ?? s?.Score ?? null;
      if (rawScore !== null && rawScore !== undefined) {
        const numeric = Number(rawScore);
        score = Number.isFinite(numeric) ? numeric : null;
      }
    } catch(e){}
    const summaryEl = card.querySelector('.rec-summary') || card.querySelector('.right > .rec-summary') || card.lastElementChild;
    if (summaryEl) summaryEl.innerHTML = '';
    card.__assessment = assessJson;
    // draw donut on card canvas
    try{
      const canvas = card.querySelector('canvas');
      if (canvas){ drawDonutOnCanvas(canvas, Number(score)); }
    }catch(e){}
    // populate word table if available; enable the toggle button when words exist
    let bestUtterance = null;
    try{
      const root = pickNBestRoot(assessJson) || pickNBestRoot(assessJson?.result) || pickNBestRoot(assessJson?.result?.result) || null;
      let words = [];
      if (root && Array.isArray(root.NBest) && root.NBest[0]){
        bestUtterance = root.NBest[0];
        words = bestUtterance.Words || bestUtterance.PronunciationAssessment?.Words || [];
      } else if (assessJson && Array.isArray(assessJson.NBest) && assessJson.NBest[0]){
        bestUtterance = assessJson.NBest[0];
        words = bestUtterance.Words || bestUtterance.PronunciationAssessment?.Words || [];
      } else if (assessJson && assessJson.Words && Array.isArray(assessJson.Words)){
        words = assessJson.Words;
      }
    const wordsTable = card.querySelector('.word-table tbody');
      if (wordsTable){
        wordsTable.innerHTML = '';
        for (const w of words){
          const wa = w.PronunciationAssessment || w;
          const wordText = w.Word || w.Display || w?.WordText || '';
          const acc = (wa && (wa.AccuracyScore ?? wa.AccScore ?? wa.PronunciationAssessment?.AccuracyScore)) ?? 'N/A';
          const errorType = wa?.ErrorType || wa?.PronunciationAssessment?.ErrorType || 'None';
          const label = { 'None':'‚úÖ Ê≠£„Åó„ÅèÁô∫Èü≥','Omission':'‚ö†Ô∏è ËÑ±ËêΩ','Mispronunciation':'üåÄ Ë™§„Çä','Insertion':'‚ûï ÊåøÂÖ•' }[errorType] || errorType;
          const tr = document.createElement('tr');
          tr.innerHTML = `<td style="text-align:center">${wordText}</td><td style="text-align:center"><strong>${acc}</strong></td><td style="text-align:center">${label}</td>`;
          wordsTable.appendChild(tr);
        }
        const wc = card.querySelector('.word-table');
        if (wc){
          // keep hidden by default, but enable toggle button
          wc.style.display = 'none';
          const tb = card.querySelector('.toggle-words-btn'); if (tb) { tb.disabled = false; tb.textContent = 'ÂçòË™ûË©ï‰æ°„ÇíË¶ã„Çã'; }
        }
      }
    }catch(e){ console.warn('markCardAssessed word table', e); }

    try {
      const transcript = (() => {
        if (!bestUtterance) return '';
        return String(bestUtterance.Display || bestUtterance.Lexical || bestUtterance.ITN || bestUtterance.Word || '').trim();
      })();
      const paNode = bestUtterance?.PronunciationAssessment || assessJson?.PronunciationAssessment || {};
      const accuracyScore = Number(paNode?.AccuracyScore ?? paNode?.AccScore ?? paNode?.Accuracy ?? paNode?.AccuracyScorePercent);
      const fluencyScore = Number(paNode?.FluencyScore ?? paNode?.FluScore ?? paNode?.Fluency);
      const completenessScore = Number(paNode?.CompletenessScore ?? paNode?.CompScore ?? paNode?.Completeness);
      const hasMetrics = [accuracyScore, fluencyScore, completenessScore].some(val => Number.isFinite(val));
      const metrics = [];
      if (Number.isFinite(accuracyScore)) metrics.push(`Á≤æÂ∫¶ ${Math.round(accuracyScore)}ÁÇπ`);
      if (Number.isFinite(fluencyScore)) metrics.push(`ÊµÅÊö¢„Åï ${Math.round(fluencyScore)}ÁÇπ`);
      if (Number.isFinite(completenessScore)) metrics.push(`ÂÆåÊàêÂ∫¶ ${Math.round(completenessScore)}ÁÇπ`);
      const entryTimestamp = (() => {
        if (!savedAt) return new Date().toISOString();
        const parsed = new Date(savedAt);
        return Number.isNaN(parsed.getTime()) ? new Date().toISOString() : parsed.toISOString();
      })();
      if (Number.isFinite(score) || hasMetrics) {
        appendEvaluationHistory(
          'pronunciation',
          sectionIdx,
          transcript || `Èå≤Èü≥ ${new Date(entryTimestamp).toLocaleString('ja-JP')}`,
          metrics.length ? metrics.join(' / ') : 'ÂçòË™û„Åî„Å®„ÅÆÂà§ÂÆö„ÅØÈå≤Èü≥„Ç´„Éº„Éâ„Çí„ÅîÁ¢∫Ë™ç„Åè„Å†„Åï„ÅÑ„ÄÇ',
          Number.isFinite(score) ? normalizeScoreValue(score) : null,
          entryTimestamp
        );
      }
    } catch (historyErr) {
      console.warn('append pronunciation history failed', historyErr);
    }
    if (savedAt) setCardTimestamp(card, savedAt);
    reorderRecordingList(listEl);
    updateEntrySummary(sectionIdx);
  }catch(e){ console.warn('markCardAssessed', e); }
}

// draw donut/arc on the given canvas; if score is null, show hollow gray circle
function drawDonutOnCanvas(canvas, score){
  try{
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height; const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 6;
    ctx.clearRect(0,0,w,h);
    // background track
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.strokeStyle = '#eee'; ctx.lineWidth = 8; ctx.stroke();
    if (score === null || score === undefined || Number.isNaN(Number(score))){
      // keep ring empty until score arrives
      return;
    }
    const p = Math.max(0, Math.min(1, Number(score)/100));
    const start = -0.5*Math.PI, end = start + p * Math.PI * 2;
    // gradient stroke
    const grad = ctx.createLinearGradient(0,0,w,h); grad.addColorStop(0,'#f97316'); grad.addColorStop(1,'#4caf50');
    ctx.beginPath(); ctx.arc(cx,cy,r,start,end); ctx.strokeStyle = grad; ctx.lineWidth = 8; ctx.lineCap = 'round'; ctx.stroke();
  ctx.font = 'bold 16px sans-serif'; ctx.fillStyle = '#222'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText((Number(score).toFixed(1)), cx, cy);
  }catch(e){ console.warn('drawDonutOnCanvas', e); }
}

// helper: find the NBest-containing root object for various Azure response shapes
function pickNBestRoot(obj){
  if (!obj || typeof obj !== 'object') return null;
  if (Array.isArray(obj.NBest) && obj.NBest.length) return obj;
  if (obj.result && Array.isArray(obj.result.NBest) && obj.result.NBest.length) return obj.result;
  if (obj.result && obj.result.result && Array.isArray(obj.result.result.NBest) && obj.result.result.NBest.length) return obj.result.result;
  // sometimes the payload is already the NBest array
  if (Array.isArray(obj) && obj.length && obj[0] && (obj[0].Words || obj[0].Word)) return { NBest: obj };
  // fallbacks
  if (obj.NBest && Array.isArray(obj.NBest)) return obj;
  return null;
}

updateAuthBar();

(async function bootstrap(){
  try {
    await ensureAuthenticated();
    await refreshUsageState({ silent: true, skipIfLoading: true });
    currentAuthUserId = authState.userId;
    PAGE_PREFIX = computePagePrefix();
    buildSections();
    updateAllQuotaDisplays();
  } catch (e) {
    console.error('initialization failed', e);
  }
})();

</script>

<footer style="max-width: 820px; margin: 2rem auto 0 auto; padding: 1rem; text-align: center; font-size: 0.9rem; color: #6b7280; border-top: 1px solid #e5e7eb;">
  Âá∫ÂÖ∏ÔºöVoice of AmericaÔºàVOAÔºâ„Çà„ÇäÂºïÁî®
</footer>

</body>
</html>