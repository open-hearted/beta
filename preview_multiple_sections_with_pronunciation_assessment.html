<!-- 2025-08-10 ä½œæˆ å„ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ç™ºéŸ³è©•ä¾¡æ©Ÿèƒ½ã‚’å«ã‚€ -->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>chatgpt + wav è¤‡æ•°ã‚»ã‚¯ã‚·ãƒ§ãƒ³</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* make sizing predictable and avoid horizontal overflow */
    *, *::before, *::after { box-sizing: border-box; }
    html, body { overflow-x: hidden; }
  body { font-family: sans-serif; padding: 1rem; background: #f0f2f5; max-width: none; width: 100%; margin: 0; line-height: 1.6; }
    .card { background: transparent; border: none; padding: 0; margin-bottom: 2rem; box-shadow: none; }
    .entry { border: 1px solid #ddd; border-radius: 12px; background: #fff; overflow: hidden; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.05); }
  .entry summary { position: relative; list-style: none; display: flex; align-items: center; gap: 12px; flex-wrap: wrap; padding: 1rem 1.25rem; background: #f7f8fc; cursor: pointer; font-weight: 600; color: #1f2937; }
  .entry summary::before { content: '\25B6'; color: #6366f1; font-size: 0.85rem; transition: transform 0.2s ease; }
  .entry.expanded summary::before,
  .entry[open] summary::before { transform: rotate(90deg); }
    .entry summary::-webkit-details-marker { display: none; }
    .entry.expanded summary,
    .entry[open] summary { border-bottom: 1px solid #e5e7eb; background: #eef2ff; }
  .entry-title { flex: 0 0 auto; font-size: 1.05rem; }
    .entry-snippet { flex: 2 1 240px; font-size: 0.95rem; color: #6b7280; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .entry-status { position: absolute; left: 50%; transform: translateX(-50%); font-size: 0.9rem; color: #374151; white-space: nowrap; }
    .entry-body { padding: 1.25rem; background: white; }
    h1 { font-size: 2rem; color: #333; margin-bottom: 1rem; text-align: center; }
    h2 { font-size: 1.3rem; color: #555; margin-bottom: 1rem; border-bottom: 2px solid #eee; padding-bottom: 0.5rem; }
    h3 { font-size: 1.1rem; color: #666; margin-bottom: 0.8rem; }
    input[type="text"], input[type="file"], textarea { width: 100%; padding: 0.7rem; margin: 0.5rem 0; font-size: 1rem; border: 2px solid #ddd; border-radius: 6px; box-sizing: border-box; transition: border-color 0.3s; }
    button { background-color: #4caf50; color: white; border: none; padding: 0.7rem 1.2rem; font-size: 1rem; border-radius: 6px; cursor: pointer; margin: 0.3rem 0.5rem 0.3rem 0; transition: background-color 0.3s; }
    button:hover { background-color: #45a049; }
    button:disabled { background-color: #ccc; cursor: not-allowed; }
    audio { width: 100%; margin: 1rem 0; border-radius: 6px; }
    .subtitle { font-size: 1.4rem; margin-bottom: 1.5rem; }
    .status { margin-top: 0.5rem; font-size: 1rem; color: #333; }
    .collapsible { background-color: #eee; cursor: pointer; padding: 0.5rem 1rem; border: none; font-size: 0.95rem; margin-top: 0.8rem; width: 100%; border-radius: 6px; text-align: left; }
    .collapsible:hover { background-color: #ddd; }
  .content { display: none; background-color: #fafafa; padding: 1rem; border: 1px solid #ccc; margin-top: 0.5rem; border-radius: 6px; white-space: pre-wrap; }
  .pending-preview { display: none; margin-top: 0.75rem; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 8px; background: #fff; }
  .pending-preview audio { flex: 1 1 auto; width: auto; min-width: 180px; }
  .pending-preview-row { display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap; }
  .pending-preview-header { font-weight: 600; font-size: 0.95rem; color: #1f2937; margin-bottom: 0.5rem; }
  .pending-preview button { background-color: #ef4444; }
  .pending-preview button:hover { background-color: #dc2626; }
  .evaluation-block { background: #f9fafb; border: 1px solid #d1d5db; border-radius: 10px; padding: 1rem; margin-top: 1rem; }
  .evaluation-header { display: flex; align-items: center; gap: 0.75rem; margin: 0 0 0.5rem 0; }
  .evaluation-title { margin: 0; font-size: 1.1rem; color: #374151; }
  .evaluation-header button { margin: 0 0 0 auto; }
  .pronunciation-controls { display: flex; gap: 8px; align-items: center; margin-top: 8px; flex-wrap: wrap; }
  .pronunciation-controls .rec-toggle { display: inline-flex; align-items: center; gap: 6px; padding: 0.65rem 1.1rem; background-color: #2563eb; }
  .pronunciation-controls .rec-toggle.recording { background-color: #dc2626; }
  .pronunciation-controls .pronunciation-submit { margin-left: auto; }
  .evaluation-history { margin-top: 0.75rem; border-top: 1px dashed #d1d5db; padding-top: 0.75rem; display: flex; flex-direction: column; gap: 0.75rem; }
  .history-entry { background: #fff; border: 1px solid #e5e7eb; border-radius: 8px; padding: 0.75rem; display: flex; flex-direction: column; gap: 0.5rem; }
  .history-entry-header { display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; color: #6b7280; }
  .history-row { display: flex; gap: 0.5rem; align-items: flex-start; }
  .history-label { font-weight: 600; min-width: 3rem; color: #374151; font-size: 0.9rem; }
  .history-text { flex: 1 1 auto; white-space: pre-wrap; word-break: break-word; font-size: 0.95rem; color: #1f2937; }
  .history-empty { font-size: 0.9rem; color: #6b7280; }
    #scoreBlock { margin: 1rem 0; text-align: center; }
    #wordsBlock { margin-top: 1rem; }
    table { width: 100%; border-collapse: collapse; text-align: left; }
    th, td { border: 1px solid #ddd; padding: 0.5rem; }
    th { background: #f8f9fa; }
  /* recording card layout */
  .rec-card { display:flex; gap:12px; align-items:flex-start; background: #fff; border-radius:8px; padding:8px; width:100%; box-sizing:border-box; flex-wrap:wrap; }
  .rec-card .left { display:flex; align-items:center; justify-content:flex-start; flex:0 0 auto; gap:10px; }
  .rec-card .right { flex:1 1 auto; min-width:0; }
  .rec-card canvas { background:transparent; }
  .word-table { margin-top:8px; font-size:0.92rem; border-top:1px dashed #eee; padding-top:8px; }
    @media (max-width: 768px) { body { padding: 0.5rem; } .card { padding: 1rem; } h1 { font-size: 1.5rem; } button { padding: 0.6rem 1rem; font-size: 0.9rem; } }
  </style>
</head>
<body>

<h1>æ¯æ—¥ãŒæˆé•·æ—¥ï¼šãƒªã‚¹ãƒ‹ãƒ³ã‚°ï¼†ç™ºéŸ³ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°é“å ´</h1>
<audio controls src="" id="fullAudio" style="width: 100%; max-width: 800px; margin: 0 auto 2rem auto; display: block;"></audio>
<div id="sentence-sections"></div>

<script>
'use strict';
// ä¾‹æ–‡ï¼ˆé©å®œå¤‰æ›´å¯ï¼‰
const sentences = [
  "Many iPhones and other Apple products are made in China.",
  "In recent years, Apple has expanded its manufacturing into other countries such as Vietnam and India.",
  "But not so much to the United States.",
  "That is changing.",
  "This week, Apple said that over the next 4 years it would invest $500 billion in the US with plans that include building a Texas facility to manufacture artificial intelligence servers and commit to creating 20,000 US jobs.",
  "Apple's announcement follows a meeting last week between CEO Tim Cook and President Donald Trump.",
  "The iPhone maker is among US firms recently announcing domestic investment and job creation.",
  "\"...and they're going to build here instead because they don't want to pay the tariffs.\"",
  "In a social media post on Thursday, Trump doubled the 10% universal tariff imposed on China, effective Tuesday.",
  "Observers say that Apple's move is part of its trend to diversify its supply chain and it's not related to Trump's tariffs on China.",
  "I mean, they are now in the, in, have been for some years, i.., in the process of , uh, moving production away from China anyway, uh,  pre-tariff.",
  "There's still a substantial amount in China, but, uhm.",
  "Th, there's a trend here that's clear, and I think that Apple will continue that.",
  "While much of Apple's plans had been known, the company is signaling its pro-US jobs and investment policy, a priority for the Trump administration.",
  "They're just taking the opportunity to use, you know, the press releases to try to just get some more public exposure for a lot of things they were already spending and and obviously align well with kind of a pro, pro US policy.",
  "As part of its US investment, Apple said it would produce its advanced silicon chips in the Arizona plant of TSMC, the Taiwanese semiconductor firm.",
  "Michelle Quinn, VOA news."
];
const audioFolderName = "With $500B US investment, Apple pulling away from China, analysts say";
// Encode folder name so static hosts serve files even with spaces/symbols in path
const base = `./${encodeURIComponent(audioFolderName)}`;
const container = document.getElementById("sentence-sections");

// Set up full audio player
const fullAudio = document.getElementById("fullAudio");
if (fullAudio) {
  fullAudio.src = `${base}/full_audio.mp3`;
}

const AUTH_STORAGE_KEY = 'ela_auth_session';
const authState = { token: null, userId: null, expiresAt: 0 };
let PAGE_PREFIX = '';
let currentAuthUserId = null;

function sanitizeUserIdForClient(id) {
  return String(id || '').trim().replace(/[^A-Za-z0-9._-]/g, '_');
}

function setAuthState(token, userId, expiresAt) {
  authState.token = token;
  authState.userId = userId;
  authState.expiresAt = expiresAt;
  try {
    const payload = JSON.stringify({ token, userId, expiresAt });
    localStorage.setItem(AUTH_STORAGE_KEY, payload);
  } catch (e) {
    console.warn('persist auth failed', e);
  }
}

function clearAuthState() {
  authState.token = null;
  authState.userId = null;
  authState.expiresAt = 0;
  try { localStorage.removeItem(AUTH_STORAGE_KEY); } catch {}
}

function loadAuthFromStorage() {
  try {
    const raw = localStorage.getItem(AUTH_STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed || typeof parsed !== 'object') return null;
    if (!parsed.token || !parsed.userId || !parsed.expiresAt) return null;
    return parsed;
  } catch (e) {
    console.warn('load auth storage failed', e);
    return null;
  }
}

function getStorageNamespace() {
  return authState.userId ? `user_${sanitizeUserIdForClient(authState.userId)}` : 'anon';
}

function namespacedKey(base) {
  return `${getStorageNamespace()}::${base}`;
}

function storageGet(baseKey) {
  try {
    return localStorage.getItem(namespacedKey(baseKey));
  } catch (e) {
    console.warn('storageGet failed', e);
    return null;
  }
}

function storageSet(baseKey, value) {
  try {
    localStorage.setItem(namespacedKey(baseKey), value);
  } catch (e) {
    console.warn('storageSet failed', e);
  }
}

function storageRemove(baseKey) {
  try {
    localStorage.removeItem(namespacedKey(baseKey));
  } catch (e) {
    console.warn('storageRemove failed', e);
  }
}

const EVAL_HISTORY_LIMIT = 20;
const LISTENING_EVAL_LIMIT = 10;
const TRANSLATION_EVAL_LIMIT = 10;
const PRONUNCIATION_EVAL_LIMIT = 10;

function evaluationHistoryKey(type, idx) {
  return `${type}History_${idx}`;
}

function sanitizeHistoryEntry(entry) {
  if (!entry || typeof entry !== 'object') return null;
  const input = String(entry.input ?? entry.listen ?? entry.student ?? '').trim();
  const feedback = String(entry.feedback ?? entry.result ?? entry.response ?? '').trim();
  if (!input && !feedback) return null;
  const rawTs = entry.createdAt || entry.savedAt || entry.timestamp || entry.time;
  let iso = null;
  if (rawTs) {
    const parsed = new Date(rawTs);
    if (!Number.isNaN(parsed.getTime())) iso = parsed.toISOString();
  }
  if (!iso) iso = new Date().toISOString();
  return { input, feedback, createdAt: iso };
}

function loadEvaluationHistory(type, idx) {
  const raw = storageGet(evaluationHistoryKey(type, idx));
  if (!raw) return [];
  try {
    const parsed = JSON.parse(raw);
    if (Array.isArray(parsed)) {
      return parsed
        .map(sanitizeHistoryEntry)
        .filter(Boolean)
        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
    }
  } catch (e) {
    console.warn('loadEvaluationHistory parse failed', e);
  }
  return [];
}

function saveEvaluationHistory(type, idx, history) {
  const clean = Array.isArray(history)
    ? history.map(sanitizeHistoryEntry).filter(Boolean)
    : [];
  try {
    storageSet(evaluationHistoryKey(type, idx), JSON.stringify(clean.slice(0, EVAL_HISTORY_LIMIT)));
  } catch (e) {
    console.warn('saveEvaluationHistory failed', e);
  }
}

function mergeHistoryEntries(primaryEntries, secondaryEntries = []) {
  const merged = [];
  const seen = new Set();
  const pushEntry = (entry) => {
    const clean = sanitizeHistoryEntry(entry);
    if (!clean) return;
    const key = `${clean.createdAt}__${clean.input}__${clean.feedback}`;
    if (seen.has(key)) return;
    seen.add(key);
    merged.push(clean);
  };
  [...(Array.isArray(primaryEntries) ? primaryEntries : []), ...(Array.isArray(secondaryEntries) ? secondaryEntries : [])].forEach(pushEntry);
  merged.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  return merged.slice(0, EVAL_HISTORY_LIMIT);
}

function formatHistoryTimestamp(isoString) {
  if (!isoString) return '';
  const d = new Date(isoString);
  if (Number.isNaN(d.getTime())) return '';
  try {
    return d.toLocaleString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
  } catch (e) {
    return d.toISOString();
  }
}

function renderEvaluationHistory(type, idx, entries) {
  const container = document.getElementById(`${type}History_${idx}`);
  if (!container) return;
  const history = Array.isArray(entries) ? entries : loadEvaluationHistory(type, idx);
  container.innerHTML = '';
  if (!history.length) {
    const empty = document.createElement('div');
    empty.className = 'history-empty';
    empty.textContent = type === 'translation' ? 'ã¾ã ç¿»è¨³è©•ä¾¡ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚' : 'ã¾ã ãƒªã‚¹ãƒ‹ãƒ³ã‚°è©•ä¾¡ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚';
    container.appendChild(empty);
    return;
  }
  history.forEach(entry => {
    const wrapper = document.createElement('div');
    wrapper.className = 'history-entry';

    const header = document.createElement('div');
    header.className = 'history-entry-header';
    const timeEl = document.createElement('time');
    timeEl.textContent = formatHistoryTimestamp(entry.createdAt) || 'æ—¥æ™‚ä¸æ˜';
    header.appendChild(timeEl);
    const typeBadge = document.createElement('span');
    typeBadge.textContent = type === 'translation' ? 'ç¿»è¨³è©•ä¾¡' : 'ãƒªã‚¹ãƒ‹ãƒ³ã‚°è©•ä¾¡';
    header.appendChild(typeBadge);
    wrapper.appendChild(header);

    const inputRow = document.createElement('div');
    inputRow.className = 'history-row';
    const inputLabel = document.createElement('span');
    inputLabel.className = 'history-label';
    inputLabel.textContent = 'å…¥åŠ›';
    const inputText = document.createElement('div');
    inputText.className = 'history-text';
    inputText.textContent = entry?.input || '';
    inputRow.appendChild(inputLabel);
    inputRow.appendChild(inputText);
    wrapper.appendChild(inputRow);

    const feedbackRow = document.createElement('div');
    feedbackRow.className = 'history-row';
    const feedbackLabel = document.createElement('span');
    feedbackLabel.className = 'history-label';
    feedbackLabel.textContent = 'è©•ä¾¡';
    const feedbackText = document.createElement('div');
    feedbackText.className = 'history-text';
    feedbackText.textContent = entry?.feedback || '';
    feedbackRow.appendChild(feedbackLabel);
    feedbackRow.appendChild(feedbackText);
    wrapper.appendChild(feedbackRow);

    container.appendChild(wrapper);
  });
}

function appendEvaluationHistory(type, idx, input, feedback, createdAt = null, options = {}) {
  const baseEntry = sanitizeHistoryEntry({ input, feedback, createdAt });
  if (!baseEntry) return;
  const current = loadEvaluationHistory(type, idx);
  if (!options.allowDuplicate) {
    const exists = current.some(entry => entry.input === baseEntry.input && entry.feedback === baseEntry.feedback && entry.createdAt === baseEntry.createdAt);
    if (exists) {
      renderEvaluationHistory(type, idx, current);
      return;
    }
  }
  const merged = mergeHistoryEntries([baseEntry, ...current]);
  saveEvaluationHistory(type, idx, merged);
  renderEvaluationHistory(type, idx, merged);
}

function getEvaluationHistoryCount(type, idx) {
  return loadEvaluationHistory(type, idx).length;
}

function pronunciationAttemptsKey(idx) {
  return `pronunciationAttempts_${idx}`;
}

function getStoredPronunciationAttempts(idx) {
  const raw = storageGet(pronunciationAttemptsKey(idx));
  const n = Number(raw);
  return Number.isFinite(n) && n >= 0 ? Math.floor(n) : 0;
}

function setPronunciationAttempts(idx, count) {
  storageSet(pronunciationAttemptsKey(idx), String(Math.max(0, Math.floor(count))));
}

function getPronunciationAssessmentCount(idx) {
  const recList = document.getElementById(`recList_${idx}`);
  if (!recList) return 0;
  return Array.from(recList.querySelectorAll('.rec-card')).filter(card => card.dataset.assessed === 'true').length;
}

function getPronunciationAttempts(idx) {
  return Math.max(getStoredPronunciationAttempts(idx), getPronunciationAssessmentCount(idx));
}

function incrementPronunciationAttempts(idx) {
  const currentStored = getStoredPronunciationAttempts(idx);
  const assessedCount = getPronunciationAssessmentCount(idx);
  const next = Math.max(currentStored + 1, assessedCount);
  setPronunciationAttempts(idx, next);
  return next;
}

function isPronunciationLimitReached(idx) {
  try {
    return getPronunciationAttempts(idx) >= PRONUNCIATION_EVAL_LIMIT;
  } catch (e) {
    console.warn('isPronunciationLimitReached failed', e);
    return false;
  }
}

function computePagePrefix() {
  const safeUser = sanitizeUserIdForClient(authState.userId || 'anon');
  let p = location.host + location.pathname;
  p = p.replace(/[^A-Za-z0-9._\-/]/g, '_');
  if (!p.endsWith('/')) p += '/';
  return `${safeUser}/${p}`;
}

async function validateToken() {
  if (!authState.token) return false;
  try {
    const res = await fetch('/api/auth', {
      method: 'GET',
      headers: { Authorization: `Bearer ${authState.token}` }
    });
    if (!res.ok) return false;
    const data = await res.json().catch(() => null);
    if (!data || !data.userId) return false;
    authState.userId = data.userId;
    if (data.expiresAt) authState.expiresAt = data.expiresAt;
    return true;
  } catch (e) {
    console.warn('token validation failed', e);
    return false;
  }
}

function buildLoginOverlay() {
  const overlay = document.createElement('div');
  overlay.id = 'authOverlay';
  overlay.style = `position:fixed;inset:0;background:rgba(17,24,39,0.85);display:flex;align-items:center;justify-content:center;z-index:9999;`;
  overlay.innerHTML = `
    <div style="background:#fff;border-radius:12px;padding:24px;max-width:360px;width:92%;box-shadow:0 12px 30px rgba(0,0,0,0.25);">
      <h2 style="margin:0 0 16px 0;font-size:1.25rem;color:#111827;text-align:center;">ãƒ­ã‚°ã‚¤ãƒ³</h2>
      <form id="authForm" style="display:flex;flex-direction:column;gap:12px;">
        <label style="display:flex;flex-direction:column;font-size:0.95rem;color:#374151;gap:4px;">
          ãƒ¦ãƒ¼ã‚¶ãƒ¼ID
          <input type="text" name="userId" required style="padding:0.6rem;border:1px solid #d1d5db;border-radius:6px;font-size:1rem;" autocomplete="username" />
        </label>
        <label style="display:flex;flex-direction:column;font-size:0.95rem;color:#374151;gap:4px;">
          ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰
          <input type="password" name="password" required style="padding:0.6rem;border:1px solid #d1d5db;border-radius:6px;font-size:1rem;" autocomplete="current-password" />
        </label>
        <button type="submit" style="margin-top:4px;background:#2563eb;color:#fff;padding:0.65rem;border-radius:6px;font-size:1rem;font-weight:600;border:none;cursor:pointer;">ãƒ­ã‚°ã‚¤ãƒ³</button>
        <div id="authStatus" style="min-height:1.2rem;font-size:0.9rem;color:#dc2626;text-align:center;"></div>
      </form>
    </div>
  `;
  return overlay;
}

async function promptForLogin() {
  return new Promise(resolve => {
    const overlay = buildLoginOverlay();
    document.body.appendChild(overlay);
    const form = overlay.querySelector('#authForm');
    const statusEl = overlay.querySelector('#authStatus');
    let busy = false;
    form.addEventListener('submit', async (ev) => {
      ev.preventDefault();
      if (busy) return;
      busy = true;
      statusEl.textContent = '';
      const formData = new FormData(form);
      const userId = String(formData.get('userId') || '').trim();
      const password = String(formData.get('password') || '');
      if (!userId || !password) {
        statusEl.textContent = 'ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
        busy = false;
        return;
      }
      try {
        const res = await fetch('/api/auth', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userId, password })
        });
        if (!res.ok) {
          const text = await res.text();
          let msg = 'èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ';
          try {
            const parsed = JSON.parse(text);
            if (parsed && parsed.error) msg = parsed.error;
          } catch {}
          statusEl.textContent = msg;
          busy = false;
          return;
        }
        const data = await res.json();
        const now = Date.now();
        const expiresInMs = (data.expiresIn || 3600) * 1000;
        setAuthState(data.token, data.userId, now + expiresInMs);
        overlay.remove();
        resolve(authState);
      } catch (e) {
        console.warn('login request failed', e);
        statusEl.textContent = 'ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ã§ã—ãŸ';
        busy = false;
      }
    });
  });
}

async function ensureAuthenticated() {
  const now = Date.now();
  if (authState.token && authState.expiresAt && authState.expiresAt > now + 5000) {
    return authState;
  }
  const stored = loadAuthFromStorage();
  if (stored && stored.token) {
    authState.token = stored.token;
    authState.userId = stored.userId;
    authState.expiresAt = stored.expiresAt;
    if (stored.expiresAt && stored.expiresAt > Date.now() + 5000) {
      const ok = await validateToken();
      if (ok) return authState;
    }
  }
  clearAuthState();
  return promptForLogin();
}

async function authedFetch(input, init = {}, retry = true) {
  await ensureAuthenticated();
  const options = Object.assign({}, init || {});
  const headers = new Headers(options.headers || {});
  if (authState.token) headers.set('Authorization', `Bearer ${authState.token}`);
  options.headers = headers;
  const response = await fetch(input, options);
  if (response.status === 401 && retry) {
    clearAuthState();
    await ensureAuthenticated();
    PAGE_PREFIX = computePagePrefix();
    currentAuthUserId = authState.userId;
    window.location.reload();
    throw new Error('ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒåˆ‡ã‚ŒãŸãŸã‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¾ã™');
  }
  return response;
}

function requireAuthGuard() {
  if (!authState.userId) {
    throw new Error('èªè¨¼æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
  }
}

function updateEntrySummary(idx) {
  const statusEl = document.getElementById(`status${idx}`);
  const snippetEl = document.getElementById(`summarySnippet_${idx}`);
  const entryEl = document.querySelector(`.entry[data-section="${idx}"]`);
  if (!statusEl && !snippetEl) return;

  const noteInput = document.getElementById(`note_${idx}_input`);
  const transInput = document.getElementById(`trans_${idx}_input`);
  const noteVal = (noteInput?.value || "").trim();
  const transVal = (transInput?.value || "").trim();

  let listeningHistoryCount = 0;
  let translationHistoryCount = 0;
  try { listeningHistoryCount = getEvaluationHistoryCount('listening', idx); } catch (e) {}
  try { translationHistoryCount = getEvaluationHistoryCount('translation', idx); } catch (e) {}

  const recList = document.getElementById(`recList_${idx}`);
  const recCount = recList ? recList.querySelectorAll('.rec-card').length : 0;
  const syncText = document.getElementById(`syncStatus_${idx}`)?.textContent?.trim() || "";
  const isDirty = entryEl?.dataset?.dirty === '1';

  const listeningDone = listeningHistoryCount > 0;
  const translationDone = translationHistoryCount > 0;
  const recordingDone = recCount > 0;
  if (statusEl) {
    const statuses = [
      `èãå–ã‚Š${listeningDone ? 'âœ…' : 'â¬œ'}`,
      `å’Œè¨³${translationDone ? 'âœ…' : 'â¬œ'}`,
      `éŒ²éŸ³${recordingDone ? 'âœ…' : 'â¬œ'}`
    ];
    statusEl.textContent = statuses.join('ã€€');
    const extras = [];
    if (isDirty) extras.push('æœªä¿å­˜ã®å¤‰æ›´ã‚ã‚Š');
    if (/ä¿å­˜ä¸­/.test(syncText)) extras.push('ä¿å­˜ä¸­');
    else if (/ä¿å­˜æ¸ˆ/.test(syncText) || /èª­ã¿è¾¼ã¿/.test(syncText)) extras.push('ã‚µãƒ¼ãƒãƒ¼ã¨åŒæœŸæ¸ˆã¿');
    else if (/å¤±æ•—/.test(syncText)) extras.push('ä¿å­˜ã«å¤±æ•—');
    else if (/ã‚ã‚Šã¾ã›ã‚“/.test(syncText)) extras.push('ã‚µãƒ¼ãƒãƒ¼ãƒ‡ãƒ¼ã‚¿ãªã—');
    statusEl.title = extras.length ? extras.join(' / ') : '';
  }

  if (snippetEl) {
    snippetEl.textContent = '';
    snippetEl.style.display = 'none';
  }
}

const totalSections = sentences.length;

function buildSections() {
  requireAuthGuard();
  container.innerHTML = '';
  sentences.forEach((sentence, idx) => {
    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
    <details class="entry" data-section="${idx}">
      <summary>
        <span class="entry-title">${idx + 1}/${totalSections}</span>
        <span class="entry-status" id="status${idx}">èãå–ã‚Šâ¬œã€€å’Œè¨³â¬œã€€éŒ²éŸ³â¬œ</span>
        <span class="entry-snippet" id="summarySnippet_${idx}" style="display:none;"></span>
      </summary>
      <div class="entry-body">
        <audio controls src="${base}/${idx + 1}.mp3"></audio>
        <div id="syncStatus_${idx}" style="font-size:0.9rem;color:#4b5563;margin-bottom:10px"></div>
    <button class="collapsible script-toggle primary-script">ğŸ“œ ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’è¡¨ç¤º</button>
    <div class="content script-content primary-script-content" style="display:none;"></div>
        <div class="evaluation-block listening-block">
          <div class="evaluation-header">
            <h3 class="evaluation-title">ãƒªã‚¹ãƒ‹ãƒ³ã‚°è©•ä¾¡</h3>
            <button id="note_${idx}_compare">ãƒªã‚¹ãƒ‹ãƒ³ã‚°è©•ä¾¡</button>
          </div>
          <textarea id="note_${idx}_input" placeholder="èã“ãˆãŸæ–‡ã‚’å…¥åŠ›â€¦"></textarea>
          <div class="evaluation-history" id="listeningHistory_${idx}"></div>
        </div>
        <div class="evaluation-block translation-block">
          <div class="evaluation-header">
            <h3 class="evaluation-title">ç¿»è¨³è©•ä¾¡</h3>
            <button id="trans_${idx}_compare">ç¿»è¨³è©•ä¾¡</button>
          </div>
          <textarea id="trans_${idx}_input" placeholder="æ—¥æœ¬èªè¨³ã‚’å…¥åŠ›â€¦"></textarea>
          <div class="evaluation-history" id="translationHistory_${idx}"></div>
        </div>
        <div class="evaluation-block pronunciation-block">
          <div class="evaluation-header">
            <h3 class="evaluation-title">ç™ºéŸ³è©•ä¾¡</h3>
          </div>
          <audio controls src="${base}/${idx + 1}.mp3" class="sample-audio" style="margin-top:0.5rem;margin-bottom:0.5rem;"></audio>
          <button class="collapsible script-toggle secondary-script">ğŸ“œ ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’è¡¨ç¤º</button>
          <div class="content script-content secondary-script-content" style="display:none;"></div>
          <div class="pronunciation-controls">
            <button id="recToggle_${idx}" class="rec-toggle">ğŸ™ï¸ éŒ²éŸ³é–‹å§‹</button>
            <span id="recStatus_${idx}" style="margin-left:8px;color:#4b5563;font-size:0.95rem;"></span>
            <span id="recTimer_${idx}" style="margin-left:8px;color:#b91c1c;font-weight:600;"></span>
            <button id="submitBtn_${idx}" class="pronunciation-submit" disabled>ç™ºéŸ³è©•ä¾¡ã‚’å®Ÿè¡Œ</button>
          </div>
          <pre id="result_${idx}" style="margin:0;padding:0;"></pre>
          <div id="pendingPreview_${idx}" class="pending-preview"></div>
          <div id="recList_${idx}" style="margin-top:10px;"></div>
          <div id="scoreBlock_${idx}"></div>
        </div>
      </div>
    </details>
    `;
    container.appendChild(card);
    setupBlock(idx, sentence);
  });
}

function setupBlock(idx, sentence) {
  const cardRoot = container.children[idx];
  const entryEl = cardRoot?.querySelector(".entry");
  const primaryScriptBtn = cardRoot?.querySelector(".primary-script");
  const primaryScriptContent = cardRoot?.querySelector(".primary-script-content");
  const secondaryScriptBtn = cardRoot?.querySelector(".secondary-script");
  const secondaryScriptContent = cardRoot?.querySelector(".secondary-script-content");

  const noteInput = document.getElementById(`note_${idx}_input`);
  const transInput = document.getElementById(`trans_${idx}_input`);
  const submitBtn = document.getElementById(`submitBtn_${idx}`);
  const pendingPreview = document.getElementById(`pendingPreview_${idx}`);
  let pendingPreviewUrl = null;
  const recToggleBtn = document.getElementById(`recToggle_${idx}`);

  if (entryEl) entryEl.dataset.dirty = '0';

  if (entryEl) {
    entryEl.addEventListener("toggle", () => {
      entryEl.classList.toggle("expanded", entryEl.open);
      if (entryEl.open) {
        container.querySelectorAll('.entry').forEach(section => {
          if (section !== entryEl && section.open) section.open = false;
        });
        fetchRemoteNotes(true);
        fetchAssessmentsForSection(true);
        setTimeout(() => {
          document.getElementById(`note_${idx}_input`)?.focus({ preventScroll: false });
        }, 50);
      } else {
        saveNotesToServer(idx);
      }
      updateEntrySummary(idx);
    });
  }

  if (primaryScriptContent) primaryScriptContent.textContent = sentence;
  if (secondaryScriptContent) secondaryScriptContent.textContent = sentence;
  noteInput.value = storageGet(`note_${idx}`) || "";
  transInput.value = storageGet(`trans_${idx}`) || "";
  renderEvaluationHistory('listening', idx);
  renderEvaluationHistory('translation', idx);
  updateEntrySummary(idx);
  setTimeout(() => {
    fetchAssessmentsForSection().catch(err => console.warn('prefetch assessments failed', err));
  }, idx * 150);

  let remoteNoteLoading = false;
  let notesLoaded = false;
  let notesDirty = false;
  let assessmentsLoaded = false;
  let assessmentLoading = false;

  async function fetchRemoteNotes(force = false) {
    if (remoteNoteLoading) return;
    if (notesLoaded && !force) return;
    remoteNoteLoading = true;
    const syncEl = document.getElementById(`syncStatus_${idx}`);
    try {
  const pagePrefix = PAGE_PREFIX || computePagePrefix();
  const sidecarKey = pagePrefix + `notes_section_${idx}.assessment.json`;
  const resp = await authedFetch(`/api/assessment?key=${encodeURIComponent(sidecarKey)}`);
      if (!resp.ok) {
        return;
      }
      const j = await resp.json().catch((error) => {
        console.warn('parse sidecar json', error);
        return null;
      });
      const item = j?.item;
      if (item && item.result && typeof item.result === 'object') {
        const r = item.result;
        if (!notesDirty) {
          if (typeof r.listening === 'string') {
            noteInput.value = r.listening;
            storageSet(`note_${idx}`, noteInput.value.trim());
          }
          if (typeof r.translation === 'string') {
            transInput.value = r.translation;
            storageSet(`trans_${idx}`, transInput.value.trim());
          }
          if (entryEl) entryEl.dataset.dirty = '0';
          notesDirty = false;
        }

        if (typeof r.pronunciationAttempts === 'number' && Number.isFinite(r.pronunciationAttempts)) {
          const current = getPronunciationAttempts(idx);
          const remoteCount = Math.max(0, Math.floor(r.pronunciationAttempts));
          if (remoteCount > current) {
            setPronunciationAttempts(idx, remoteCount);
          }
        }

        const remoteListeningHistory = Array.isArray(r.listeningHistory) ? r.listeningHistory : [];
        const remoteTranslationHistory = Array.isArray(r.translationHistory) ? r.translationHistory : [];
        const legacyListening = (!remoteListeningHistory.length && r.listening && r.listeningFeedback)
          ? [{ input: r.listening, feedback: r.listeningFeedback, createdAt: r.savedAt || item.savedAt }]
          : [];
        const legacyTranslation = (!remoteTranslationHistory.length && r.translation && r.translationFeedback)
          ? [{ input: r.translation, feedback: r.translationFeedback, createdAt: r.savedAt || item.savedAt }]
          : [];

        const mergedListening = mergeHistoryEntries([...remoteListeningHistory, ...legacyListening], loadEvaluationHistory('listening', idx));
        if (mergedListening.length) {
          saveEvaluationHistory('listening', idx, mergedListening);
          renderEvaluationHistory('listening', idx, mergedListening);
        }

        const mergedTranslation = mergeHistoryEntries([...remoteTranslationHistory, ...legacyTranslation], loadEvaluationHistory('translation', idx));
        if (mergedTranslation.length) {
          saveEvaluationHistory('translation', idx, mergedTranslation);
          renderEvaluationHistory('translation', idx, mergedTranslation);
        }

        if (syncEl) syncEl.textContent = 'ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰èª­ã¿è¾¼ã¿ã¾ã—ãŸ';
      }
    } catch (error) {
      console.warn('fetchRemoteNotes failed', error);
      if (syncEl) syncEl.textContent = 'èª­ã¿è¾¼ã¿ã«å¤±æ•—';
    } finally {
      remoteNoteLoading = false;
      notesLoaded = true;
      updateEntrySummary(idx);
    }
  }
  // localStorage for in-session persistence; server sync happens when section closes
  noteInput.addEventListener("input", () => {
    const v = noteInput.value.trim();
    storageSet(`note_${idx}`, v);
    notesDirty = true;
    if (entryEl) entryEl.dataset.dirty = '1';
    const syncEl = document.getElementById(`syncStatus_${idx}`);
    if (syncEl) syncEl.textContent = 'æœªä¿å­˜ (é–‰ã˜ã‚‹ã¨ä¿å­˜)';
    updateEntrySummary(idx);
  });
  transInput.addEventListener("input", () => {
    const v = transInput.value.trim();
    storageSet(`trans_${idx}`, v);
    notesDirty = true;
    if (entryEl) entryEl.dataset.dirty = '1';
    const syncEl = document.getElementById(`syncStatus_${idx}`);
    if (syncEl) syncEl.textContent = 'æœªä¿å­˜ (é–‰ã˜ã‚‹ã¨ä¿å­˜)';
    updateEntrySummary(idx);
  });
  const listeningBtn = document.getElementById(`note_${idx}_compare`);
  const translationBtn = document.getElementById(`trans_${idx}_compare`);
  if (listeningBtn) {
    listeningBtn.addEventListener('click', () =>
      callChatGPT({ type: 'listening', idx, inputEl: noteInput, referenceText: sentence, buttonEl: listeningBtn })
    );
  }
  if (translationBtn) {
    translationBtn.addEventListener('click', () =>
      callChatGPT({ type: 'translation', idx, inputEl: transInput, referenceText: sentence, buttonEl: translationBtn })
    );
  }

  // save note/translation pair to server sidecar for cross-device sync
  async function saveNotesToServer(sectionIdx){
    if (!notesDirty) return;
    try{
      const syncEl = document.getElementById(`syncStatus_${sectionIdx}`);
    const listening = document.getElementById(`note_${sectionIdx}_input`).value.trim();
    const translation = document.getElementById(`trans_${sectionIdx}_input`).value.trim();
    const listeningHistory = loadEvaluationHistory('listening', sectionIdx);
    const translationHistory = loadEvaluationHistory('translation', sectionIdx);
    const pronunciationAttempts = getPronunciationAttempts(sectionIdx);
      if (syncEl) syncEl.textContent = 'ä¿å­˜ä¸­â€¦';
      updateEntrySummary(sectionIdx);
  const pagePrefix = PAGE_PREFIX;
  const body = { key: pagePrefix + `notes_section_${sectionIdx}`, result: { listening, translation, listeningHistory, translationHistory, pronunciationAttempts, savedAt: new Date().toISOString() }, referenceText: '' };
  const resp = await authedFetch('/api/assessment', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
      if (resp && resp.ok) {
        if (syncEl) syncEl.textContent = 'ä¿å­˜æ¸ˆã¿';
        notesDirty = false;
        if (entryEl) entryEl.dataset.dirty = '0';
        notesLoaded = true;
      } else {
        if (syncEl) syncEl.textContent = 'ä¿å­˜ã«å¤±æ•—';
        console.warn('saveNotesToServer resp not ok', resp);
        notesDirty = true;
        if (entryEl) entryEl.dataset.dirty = '1';
      }
      updateEntrySummary(sectionIdx);
    }catch(e){
      console.warn('saveNotesToServer failed', e);
      const syncEl = document.getElementById(`syncStatus_${sectionIdx}`);
      if (syncEl) syncEl.textContent = 'ä¿å­˜ã«å¤±æ•—';
      notesDirty = true;
      if (entryEl) entryEl.dataset.dirty = '1';
      updateEntrySummary(sectionIdx);
    }
  }
  if (primaryScriptBtn && primaryScriptContent) {
    primaryScriptBtn.addEventListener("click", () => {
      const isVisible = primaryScriptContent.style.display === "block";
      primaryScriptContent.style.display = isVisible ? "none" : "block";
      primaryScriptBtn.textContent = isVisible ? "ğŸ“œ ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’è¡¨ç¤º" : "ğŸ“œ ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’é–‰ã˜ã‚‹";
    });
  }
  if (secondaryScriptBtn && secondaryScriptContent) {
    secondaryScriptBtn.addEventListener("click", () => {
      const isVisible = secondaryScriptContent.style.display === "block";
      secondaryScriptContent.style.display = isVisible ? "none" : "block";
      secondaryScriptBtn.textContent = isVisible ? "ğŸ“œ ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’è¡¨ç¤º" : "ğŸ“œ ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’é–‰ã˜ã‚‹";
    });
  }

  let lastRecordedFile = null;
  const resultBox = document.getElementById(`result_${idx}`);
  const recStatus = document.getElementById(`recStatus_${idx}`);

  function disposePendingPreview() {
    if (pendingPreview) {
      pendingPreview.innerHTML = '';
      pendingPreview.style.display = 'none';
    }
    if (pendingPreviewUrl) {
      URL.revokeObjectURL(pendingPreviewUrl);
      pendingPreviewUrl = null;
    }
  }

  function deletePendingRecording() {
    disposePendingPreview();
    lastRecordedFile = null;
    if (submitBtn) submitBtn.disabled = true;
    if (recStatus) recStatus.textContent = '';
  resultBox.textContent = 'éŒ²éŸ³ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚';
    if (recToggleBtn) {
      recToggleBtn.dataset.state = 'idle';
      recToggleBtn.textContent = 'ğŸ™ï¸ éŒ²éŸ³é–‹å§‹';
      recToggleBtn.classList.remove('recording');
    }
    updateEntrySummary(idx);
  }

  function showPendingPreview(file, url) {
    if (!pendingPreview) {
      URL.revokeObjectURL(url);
      return;
    }
    disposePendingPreview();
    pendingPreview.innerHTML = `
      <div class="pending-preview-header">éŒ²éŸ³ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</div>
      <div class="pending-preview-row">
        <audio controls src="${url}"></audio>
        <button type="button" class="pending-preview-delete">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å‰Šé™¤</button>
      </div>
    `;
    pendingPreview.style.display = 'block';
    pendingPreviewUrl = url;
    const deleteBtn = pendingPreview.querySelector('.pending-preview-delete');
    if (deleteBtn) deleteBtn.addEventListener('click', deletePendingRecording);
  }
  // ç™ºéŸ³è©•ä¾¡: éŒ²éŸ³ or ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ -> S3ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ -> Azure è©•ä¾¡ -> ã‚µã‚¤ãƒ‰ã‚«ãƒ¼ä¿å­˜ -> è¡¨ç¤º
  const API_UPLOAD = '/api/upload';
  const API_ASSESS = '/api/azure-assess';
  const API_ASSESS_SAVE = '/api/assessment';

  async function fetchAssessmentsForSection(force = false) {
    if (assessmentLoading) return;
    if (assessmentsLoaded && !force) return;
    assessmentLoading = true;
    const prefix = PAGE_PREFIX + `section_${idx}/`;
    try {
  const upl = await authedFetch('/api/upload?prefix=' + encodeURIComponent(prefix));
      if (!upl.ok) return;
      const ju = await upl.json().catch(() => null);
      if (!ju || !Array.isArray(ju.items)) return;
      const collected = [];
      for (const it of ju.items) {
        const key = it.key;
        if (!key) continue;
        try {
          let fileUrl = it.presignedUrl || it.url || null;
          if (!fileUrl) {
            const info = await authedFetch('/api/upload?key=' + encodeURIComponent(key));
            if (info.ok) {
              const infoJson = await info.json().catch(() => null);
              fileUrl = infoJson?.item?.presignedUrl || infoJson?.item?.url || fileUrl;
            }
          }
          addRecordingCard(idx, { key, url: fileUrl, fileName: key.split('/').pop(), size: it.size || 0, lastModified: it.lastModified || it.LastModified });
          const assessResp = await authedFetch('/api/assessment?key=' + encodeURIComponent(key + '.assessment.json'));
          if (!assessResp.ok) continue;
          const detail = await assessResp.json().catch(() => null);
          const payload = detail?.item;
          const result = payload?.result || null;
          if (!result) continue;
          let ts = null;
          if (payload && payload.savedAt) ts = Date.parse(payload.savedAt);
          else if (it.lastModified) ts = (new Date(it.lastModified)).getTime();
          else ts = Date.now();
          collected.push({ key, result, ts });
          const savedAt = payload?.savedAt || payload?.result?.savedAt || it.lastModified || it.LastModified;
          markCardAssessed(idx, key, result, savedAt);
        } catch (error) {
          console.warn('fetchAssessmentsForSection item failed', error);
        }
      }
      if (collected.length) {
        const latest = collected.sort((a, b) => (b.ts || 0) - (a.ts || 0))[0];
        if (latest) {
          displayResults(JSON.stringify(latest.result), idx);
        }
        const assessedTotal = collected.length;
        const currentAttempts = getPronunciationAttempts(idx);
        if (assessedTotal > currentAttempts) {
          setPronunciationAttempts(idx, assessedTotal);
        }
      }
    } catch (error) {
      console.warn('fetchAssessmentsForSection failed', error);
    } finally {
      assessmentLoading = false;
      assessmentsLoaded = true;
      updateEntrySummary(idx);
    }
  }

  // no file input: only recorded files are supported

  // recorder per-section (uses AudioWorklet if available)
  let _recorder = null; // storing state per section in closure
  async function startRecordingForSection(){
    if (recToggleBtn) {
      recToggleBtn.disabled = true;
    }
    if (submitBtn) submitBtn.disabled = true;
    disposePendingPreview();
    lastRecordedFile = null;
    if (recStatus) recStatus.textContent = '';
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const ac = new (window.AudioContext||window.webkitAudioContext)({ sampleRate: 16000 });
      try { if (ac.state === 'suspended') await ac.resume(); } catch {}
      await ac.audioWorklet.addModule('./audio-recording/audio-processor.js');
      const src = ac.createMediaStreamSource(stream);
      const node = new AudioWorkletNode(ac, 'audio-processor');
      const mute = ac.createGain(); mute.gain.value = 0;
      const chunks = [];
      node.port.onmessage = ev => chunks.push(new Float32Array(ev.data));
      src.connect(node); node.connect(mute).connect(ac.destination);
  _recorder = { ac, stream, node, mute, chunks, startedAt: performance.now(), timerId: null };
      // start timer display
      try{
        const timerEl = document.getElementById(`recTimer_${idx}`);
        const start = performance.now();
        _recorder.timerId = setInterval(()=>{
          const s = Math.floor((performance.now()-start)/1000);
          const mm = String(Math.floor(s/60)).padStart(2,'0');
          const ss = String(s%60).padStart(2,'0');
          if (timerEl) timerEl.textContent = `${mm}:${ss}`;
        }, 250);
      }catch(e){}
      if (recStatus) recStatus.textContent = 'éŒ²éŸ³ä¸­';
      if (recToggleBtn) {
        recToggleBtn.dataset.state = 'recording';
        recToggleBtn.textContent = 'â¹ï¸ éŒ²éŸ³åœæ­¢';
        recToggleBtn.classList.add('recording');
      }
      if (resultBox) resultBox.textContent = '';
    } catch(e){
      if (resultBox) resultBox.textContent = 'éŒ²éŸ³é–‹å§‹å¤±æ•—: '+e.message;
      _recorder = null;
      if (recToggleBtn) {
        recToggleBtn.dataset.state = 'idle';
        recToggleBtn.textContent = 'ğŸ™ï¸ éŒ²éŸ³é–‹å§‹';
        recToggleBtn.classList.remove('recording');
      }
    } finally {
      if (recToggleBtn) recToggleBtn.disabled = false;
    }
  }

  async function stopRecordingForSection(){
    if (!_recorder) return;
    const recorderRef = _recorder;
    if (recToggleBtn) recToggleBtn.disabled = true;
    try {
      const { stream, node, mute, chunks } = recorderRef;
      try { node && node.disconnect(); } catch {}
      try { mute && mute.disconnect(); } catch {}
      try { stream && stream.getTracks().forEach(t=>t.stop()); } catch {}
      const total = chunks.reduce((s,a)=> s + a.length, 0);
      const buf = new Float32Array(total);
      let off = 0; for (const a of chunks){ buf.set(a, off); off += a.length; }
      // resample if necessary (recorderRef.ac.sampleRate -> 16000 assumed)
      const effective = recorderRef.ac.sampleRate || 16000;
      let out = buf;
      if (Math.abs(effective - 16000) > 1) out = resampleLinear(buf, effective, 16000);
      const wav = encodeWavFromFloat32(out, 16000);
      const blob = new Blob([wav], { type: 'audio/wav' });
      // attach blob to file input (so UI still uses fileInput.files if needed)
      const file = new File([blob], `rec_${Date.now()}.wav`, { type: 'audio/wav' });
      lastRecordedFile = file;
      const previewUrl = URL.createObjectURL(blob);
      showPendingPreview(file, previewUrl);
      if (resultBox) resultBox.textContent = '';
      if (recStatus) recStatus.textContent = 'éŒ²éŸ³å®Œäº†';
      // stop timer and enable submit
    try{ if (recorderRef.timerId) clearInterval(recorderRef.timerId); const tEl = document.getElementById(`recTimer_${idx}`); if (tEl) tEl.textContent = ''; }catch(e){}
    const limitReached = isPronunciationLimitReached(idx);
    if (submitBtn) submitBtn.disabled = limitReached;
    if (limitReached && recStatus) {
      recStatus.textContent = `ç™ºéŸ³è©•ä¾¡ã¯1ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã¤ã${PRONUNCIATION_EVAL_LIMIT}å›ã¾ã§ã§ã™ã€‚`;
    }
    } catch(e){
      resultBox.textContent = 'éŒ²éŸ³åœæ­¢ã‚¨ãƒ©ãƒ¼: '+e.message;
    } finally {
      try { await recorderRef.ac.close(); } catch {}
      _recorder = null;
      if (recToggleBtn) {
        recToggleBtn.disabled = false;
        recToggleBtn.dataset.state = 'idle';
        recToggleBtn.textContent = 'ğŸ™ï¸ éŒ²éŸ³é–‹å§‹';
        recToggleBtn.classList.remove('recording');
      }
    }
  }

  if (recToggleBtn) {
    let toggleBusy = false;
  recToggleBtn.dataset.state = 'idle';
  recToggleBtn.classList.remove('recording');
  recToggleBtn.textContent = 'ğŸ™ï¸ éŒ²éŸ³é–‹å§‹';
    recToggleBtn.addEventListener('click', async () => {
      if (toggleBusy) return;
      toggleBusy = true;
      try {
        if (_recorder) {
          await stopRecordingForSection();
        } else {
          await startRecordingForSection();
        }
      } finally {
        toggleBusy = false;
      }
    });
  }
  // move the submit button into the same row as the recording controls for better UX
  try{
    if (recToggleBtn && submitBtn && recToggleBtn.parentNode && !recToggleBtn.parentNode.contains(submitBtn)){
      submitBtn.style.marginLeft = '8px';
      recToggleBtn.parentNode.appendChild(submitBtn);
    }
  }catch(e){}

  // helper: encode/resample functions (from integrated file)
  function resampleLinear(data, src, dst){ if (src === dst) return data; const ratio = src / dst, N = Math.round(data.length / ratio); const out = new Float32Array(N); for (let i=0;i<N;i++){ const p = i * ratio, i0 = Math.floor(p), i1 = Math.min(i0+1, data.length-1), t = p - i0; out[i] = data[i0]*(1-t) + data[i1]*t; } return out; }
  function encodeWavFromFloat32(ch, sr){ const len = ch.length, buf = new ArrayBuffer(44 + len*2), v = new DataView(buf); const w = (s,o)=>{ for(let i=0;i<s.length;i++) v.setUint8(o+i,s.charCodeAt(i)); }; let p=0; w('RIFF',p); p+=4; v.setUint32(p,36+len*2,true); p+=4; w('WAVE',p); p+=4; w('fmt ',p); p+=4; v.setUint32(p,16,true); p+=4; v.setUint16(p,1,true); p+=2; v.setUint16(p,1,true); p+=2; v.setUint32(p,sr,true); p+=4; v.setUint32(p,sr*2,true); p+=4; v.setUint16(p,2,true); p+=2; v.setUint16(p,16,true); p+=2; w('data',p); p+=4; v.setUint32(p,len*2,true); p+=4; for(let i=0;i<len;i++){ const s=Math.max(-1,Math.min(1,ch[i])); v.setInt16(p, s<0? s*0x8000 : s*0x7FFF, true); p+=2; } return buf; }
  function fmtBytes(b){ if (!b) return ''; if (b<1024) return b+'B'; if (b<1024*1024) return (b/1024).toFixed(1)+'KB'; return (b/1024/1024).toFixed(2)+'MB'; }

  // upload blob/file to /api/upload with prefix per section
  async function uploadFileAndAssess(fileBlob){
    resultBox.textContent = 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...';
    const fd = new FormData();
    fd.append('file', new File([fileBlob], fileBlob.name || `rec_${Date.now()}.wav`, { type: fileBlob.type || 'audio/wav' }));
    const prefix = PAGE_PREFIX + `section_${idx}/`;
    fd.append('prefix', prefix);
    let uploadResp;
    try {
      // disable submit during upload/assess
      if (submitBtn) submitBtn.disabled = true;
  uploadResp = await authedFetch(API_UPLOAD, { method:'POST', body: fd });
      if (!uploadResp.ok) {
        let detail = '';
        try {
          const errText = await uploadResp.text();
          if (errText) {
            try {
              const parsed = JSON.parse(errText);
              detail = parsed.detail || parsed.error || errText;
            } catch {
              detail = errText;
            }
          }
        } catch {}
        const message = detail ? `upload failed ${uploadResp.status}: ${detail}` : `upload failed ${uploadResp.status}`;
        throw new Error(message);
      }
      const upj = await uploadResp.json();
      const audioUrl = upj.presignedUrl || upj.url;
      const s3Key = upj.key;
      // add recording card to the UI for this section
  const nowIso = new Date().toISOString();
  try { addRecordingCard(idx, { key: s3Key, url: audioUrl, fileName: fileBlob.name || ('rec_'+Date.now()+'.wav'), size: fileBlob.size || 0, lastModified: nowIso }); } catch(e){ console.warn('addRecordingCard failed', e); }
  resultBox.textContent = 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å®Œäº†ã€‚è©•ä¾¡ä¸­â€¦';
      // call azure-assess
    const referenceText = sentence;
  const assessResp = await authedFetch(API_ASSESS, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ audioUrl, referenceText, language: 'en-US' }) });
      if (!assessResp.ok) { const t = await assessResp.text(); throw new Error('azure-assess failed: '+assessResp.status+' '+t); }
      const assessJson = await assessResp.json();
      // save assessment sidecar: key should be s3Key
  const saveResp = await authedFetch(API_ASSESS_SAVE, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ key: s3Key, result: assessJson, referenceText }) });
      if (!saveResp.ok) { const t = await saveResp.text(); throw new Error('save assessment failed: '+saveResp.status+' '+t); }
      resultBox.textContent = 'è©•ä¾¡å®Œäº†ãƒ»ä¿å­˜æ¸ˆã¿';
      // render results
    // update card with assessment marker and also render main area
  try { markCardAssessed(idx, s3Key, assessJson, nowIso); } catch(e){}
    displayResults(JSON.stringify(assessJson.result || assessJson?.result || assessJson), idx);
      const attempts = incrementPronunciationAttempts(idx);
      try {
        const listeningVal = document.getElementById(`note_${idx}_input`)?.value.trim() || '';
        const translationVal = document.getElementById(`trans_${idx}_input`)?.value.trim() || '';
        const listeningHistory = loadEvaluationHistory('listening', idx);
        const translationHistory = loadEvaluationHistory('translation', idx);
        const pageKeyPrefix = PAGE_PREFIX || computePagePrefix();
        authedFetch('/api/assessment', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            key: pageKeyPrefix + `notes_section_${idx}`,
            result: {
              listening: listeningVal,
              translation: translationVal,
              listeningHistory,
              translationHistory,
              pronunciationAttempts: attempts,
              savedAt: new Date().toISOString()
            },
            referenceText: ''
          })
        }).catch(err => console.warn('persist pronunciation attempts failed', err));
      } catch (metaErr) {
        console.warn('collect pronunciation metadata failed', metaErr);
      }
      disposePendingPreview();
      lastRecordedFile = null;
      if (recStatus) recStatus.textContent = 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿ (éŒ²éŸ³ä¸€è¦§ã‚’ç¢ºèªã—ã¦ãã ã•ã„)';
    } catch(e){
      resultBox.textContent = 'ã‚¨ãƒ©ãƒ¼: '+e.message;
    } finally {
      const limitReached = isPronunciationLimitReached(idx);
      if (submitBtn) submitBtn.disabled = limitReached || !lastRecordedFile;
      if (limitReached && recStatus) {
        recStatus.textContent = `ç™ºéŸ³è©•ä¾¡ã¯1ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã¤ã${PRONUNCIATION_EVAL_LIMIT}å›ã¾ã§ã§ã™ã€‚`;
      }
    }
    updateEntrySummary(idx);
  }

  // submit handler (file input must contain .wav or recording filled into fileInput)
  if (submitBtn) submitBtn.onclick = async () => {
    resultBox.textContent = '';
    if (!lastRecordedFile) { resultBox.textContent = 'éŒ²éŸ³ã‚’è¡Œã£ã¦ã‹ã‚‰ã€Œç™ºéŸ³è©•ä¾¡ã‚’å®Ÿè¡Œã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚'; return; }
    if (isPronunciationLimitReached(idx)) {
      alert(`ç™ºéŸ³è©•ä¾¡ã¯1ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã¤ã${PRONUNCIATION_EVAL_LIMIT}å›ã¾ã§ã§ã™ã€‚`);
      if (submitBtn) submitBtn.disabled = true;
      if (recStatus) recStatus.textContent = `ç™ºéŸ³è©•ä¾¡ã¯1ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã¤ã${PRONUNCIATION_EVAL_LIMIT}å›ã¾ã§ã§ã™ã€‚`;
      return;
    }
    await uploadFileAndAssess(lastRecordedFile);
  };

  if (submitBtn && isPronunciationLimitReached(idx)) {
    submitBtn.disabled = true;
    if (recStatus) recStatus.textContent = `ç™ºéŸ³è©•ä¾¡ã¯1ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã¤ã${PRONUNCIATION_EVAL_LIMIT}å›ã¾ã§ã§ã™ã€‚`;
  }

  // page-level word toggle removed; per-card controls are used instead
}

// ChatGPTé€£æºï¼ˆæ—¥æœ¬èªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆï¼‰
async function callChatGPT({ type, idx, inputEl, referenceText, buttonEl }) {
  const isTranslation = type === 'translation';
  const textValue = inputEl?.value ?? '';
  const userText = String(textValue).trim();
  if (!userText) {
    if (inputEl) inputEl.focus();
    return;
  }

  if (!isTranslation) {
    const existing = getEvaluationHistoryCount('listening', idx);
    if (existing >= LISTENING_EVAL_LIMIT) {
      alert(`èãå–ã‚Šè©•ä¾¡ã¯1ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã¤ã${LISTENING_EVAL_LIMIT}å›ã¾ã§ã§ã™ã€‚`);
      return;
    }
  } else {
    const existing = getEvaluationHistoryCount('translation', idx);
    if (existing >= TRANSLATION_EVAL_LIMIT) {
      alert(`ç¿»è¨³è©•ä¾¡ã¯1ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ã¤ã${TRANSLATION_EVAL_LIMIT}å›ã¾ã§ã§ã™ã€‚`);
      return;
    }
  }

  const prompt = isTranslation
    ? { system: "ä»¥ä¸‹ã¯ç¿»è¨³è©•ä¾¡ã§ã™ã€‚", template: "å­¦ç¿’è€…ã®è¨³: {{student}}\nåŸæ–‡: {{reference}}\nèª¤è¨³ã‚„ä¸è¶³ã€è‰¯ã„ç‚¹ã‚’æ—¥æœ¬èªã§ç°¡æ½”ã«æŒ‡æ‘˜ã—ã¦ãã ã•ã„ã€‚" }
    : { system: "ä»¥ä¸‹ã¯ãƒªã‚¹ãƒ‹ãƒ³ã‚°è©•ä¾¡ã§ã™ã€‚", template: "å­¦ç¿’è€…: {{student}}\næ­£è§£: {{reference}}\nå·®åˆ†ã‚’æ¯”è¼ƒã—ã€æ—¥æœ¬èªã§ç°¡æ½”ã«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚" };

  const originalLabel = buttonEl?.textContent;
  if (buttonEl) {
    buttonEl.disabled = true;
    buttonEl.textContent = 'è©•ä¾¡ä¸­â€¦';
  }

  try {
    const systemPrompt = prompt.system;
    const userPrompt = prompt.template.replace("{{student}}", userText).replace("{{reference}}", referenceText);
    const body = { model: 'gpt-4', messages: [ { role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt } ] };
    const res = await authedFetch('/api/chat', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
    if (!res.ok) throw new Error(`Error: ${res.status} ${res.statusText}`);
    const data = await res.json();
    const feedback = data.choices?.[0]?.message?.content || 'âš ï¸ å¿œç­”ãŒã‚ã‚Šã¾ã›ã‚“ã€‚';

  appendEvaluationHistory(isTranslation ? 'translation' : 'listening', idx, userText, feedback);

  const legacyKey = isTranslation ? `chatResponse_translation_${idx}` : `chatResponse_listening_${idx}`;
  storageRemove(legacyKey);

    if (inputEl) {
      inputEl.value = '';
      const storageKey = isTranslation ? `trans_${idx}` : `note_${idx}`;
      storageRemove(storageKey);
    }

    const listening = document.getElementById(`note_${idx}_input`)?.value.trim() || '';
    const translation = document.getElementById(`trans_${idx}_input`)?.value.trim() || '';
    const listeningHistory = loadEvaluationHistory('listening', idx);
    const translationHistory = loadEvaluationHistory('translation', idx);
    const pronunciationAttempts = getPronunciationAttempts(idx);

    const pageKeyPrefix = PAGE_PREFIX || computePagePrefix();
    authedFetch('/api/assessment', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        key: pageKeyPrefix + `notes_section_${idx}`,
        result: {
          listening,
          translation,
          listeningHistory,
          translationHistory,
          pronunciationAttempts,
          savedAt: new Date().toISOString()
        },
        referenceText: ''
      })
    }).catch(e => console.warn('persist chat feedback failed', e));

    const entryEl = document.querySelector(`.entry[data-section="${idx}"]`);
    if (entryEl) entryEl.dataset.dirty = '0';
    const syncEl = document.getElementById(`syncStatus_${idx}`);
    if (syncEl) syncEl.textContent = 'ä¿å­˜æ¸ˆã¿';
  } catch (e) {
    console.warn('callChatGPT failed', e);
    alert(`è©•ä¾¡ã«å¤±æ•—ã—ã¾ã—ãŸ: ${e.message}`);
  } finally {
    if (buttonEl) {
      buttonEl.disabled = false;
      buttonEl.textContent = originalLabel || (isTranslation ? 'ç¿»è¨³è©•ä¾¡' : 'ãƒªã‚¹ãƒ‹ãƒ³ã‚°è©•ä¾¡');
    }
    updateEntrySummary(idx);
  }
}

function displayResults(jsonString, idx) {
  // make function tolerant to multiple Azure response shapes
  let data;
  try { data = (typeof jsonString === 'string') ? JSON.parse(jsonString) : jsonString; } catch (e) { data = jsonString; }

  // normalize: try a few common nesting patterns where the actual NBest may live
  const pickNested = (obj) => {
    if (!obj || typeof obj !== 'object') return null;
    if (Array.isArray(obj.NBest) && obj.NBest.length) return obj;
    if (obj.result && Array.isArray(obj.result.NBest) && obj.result.NBest.length) return obj.result;
    if (obj.result && obj.result.result && Array.isArray(obj.result.result.NBest) && obj.result.result.NBest.length) return obj.result.result;
    // sometimes the payload itself is the NBest entry
    if (Array.isArray(obj) && obj.length && obj[0].Words) return { NBest: obj };
    return obj;
  };

  const normalized = pickNested(data) || data;
  // prefer first NBest entry; if missing, fallback to 'result' object
  const nb = (Array.isArray(normalized.NBest) && normalized.NBest[0]) || normalized.NBest || normalized.result || normalized;

  // PronunciationAssessment may be nested or flattened
  const pa = nb.PronunciationAssessment || nb;
  const score = pa.PronScore ?? pa.PronunciationScore ?? pa.Pron ?? pa.PronunciationScore ?? null;
  const accuracy = pa.AccuracyScore ?? pa.AccScore ?? nb.AccuracyScore ?? nb.AccScore ?? null;
  const fluency = pa.FluencyScore ?? pa.FluScore ?? nb.FluencyScore ?? nb.FluScore ?? null;
  const completeness = pa.CompletenessScore ?? pa.CompScore ?? nb.CompletenessScore ?? nb.CompScore ?? null;
  const words = nb.Words || pa.Words || [];

  // main numeric score and subscores intentionally omitted â€” per-card UI shows word-level details
  const scoreEl = document.getElementById(`scoreBlock_${idx}`);
  if (scoreEl) scoreEl.innerHTML = '';
  // also hide/clear the page-level words block to avoid duplicate information
  const wordsMain = document.getElementById(`wordsBlock_${idx}`);
  if (wordsMain) { wordsMain.style.display = 'none'; const tb = wordsMain.querySelector('tbody'); if (tb) tb.innerHTML = ''; }
  // done â€” per-card rendering handled elsewhere
  return;
  // page-level words display intentionally suppressed; details shown on recording cards
}

// ===== persistence: load saved recordings & assessments for this page =====
// small utility: format bytes -> human readable
function fmtBytes(b){
  if (!b && b !== 0) return '';
  if (b < 1024) return b + 'B';
  if (b < 1024 * 1024) return (b / 1024).toFixed(1) + 'KB';
  return (b / 1024 / 1024).toFixed(2) + 'MB';
}

function formatRelativeTime(ts){
  if (!ts) return '';
  const date = (ts instanceof Date) ? ts : new Date(ts);
  if (Number.isNaN(date.getTime())) return '';
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const minutes = Math.floor(diffMs / 60000);
  const hours = Math.floor(diffMs / 3600000);
  const days = Math.floor(diffMs / 86400000);
  if (diffMs < 0) return 'æœªæ¥ã®éŒ²éŸ³';
  if (minutes < 1) return 'ãŸã£ãŸä»Š';
  if (minutes < 60) return `${minutes}åˆ†å‰`;
  if (hours < 24 && now.toDateString() === date.toDateString()) return `${hours}æ™‚é–“å‰`;
  if (days === 1) return '1æ—¥å‰';
  if (days < 7) return `${days}æ—¥å‰`;
  return date.toLocaleString();
}

function setCardTimestamp(card, ts){
  if (!card) return;
  const date = ts ? new Date(ts) : null;
  if (!date || Number.isNaN(date.getTime())) return;
  card.dataset.lastModified = date.toISOString();
  const tsEl = card.querySelector('.rec-timestamp');
  if (tsEl) tsEl.textContent = formatRelativeTime(date);
}

function reorderRecordingList(listEl){
  if (!listEl) return;
  const cards = Array.from(listEl.children);
  cards.sort((a, b) => {
    const ta = new Date(a.dataset?.lastModified || 0).getTime();
    const tb = new Date(b.dataset?.lastModified || 0).getTime();
    return tb - ta;
  });
  cards.forEach(card => listEl.appendChild(card));
}
// create a small card element in the per-section recList to represent one recording
function addRecordingCard(sectionIdx, meta){
  try{
    const listEl = document.getElementById(`recList_${sectionIdx}`);
    if (!listEl) return;
    // avoid duplicate card for same key
    if (meta && meta.key){
      if (listEl.querySelector(`[data-s3key="${meta.key}"]`)) return;
    }
    const wrapper = document.createElement('div');
    wrapper.className = 'rec-card';
    if (meta && meta.key) wrapper.setAttribute('data-s3key', meta.key);
  if (meta && meta.lastModified) wrapper.dataset.lastModified = String(meta.lastModified);

    // left: circular score canvas
  const left = document.createElement('div'); left.className = 'left';
  left.style = 'display:flex;align-items:center;gap:10px;';
  const canvas = document.createElement('canvas'); canvas.width = 80; canvas.height = 80; canvas.style.width = '72px'; canvas.style.height = '72px';
  const toggleWordsBtn = document.createElement('button');
  toggleWordsBtn.textContent = 'å˜èª';
  toggleWordsBtn.className = 'toggle-words-btn';
  toggleWordsBtn.disabled = true;
  toggleWordsBtn.style = 'min-width:72px;';
  left.appendChild(canvas);
  left.appendChild(toggleWordsBtn);

    // right: inline row with audio + controls (donut, audio, buttons on one line)
    const right = document.createElement('div'); right.className = 'right';
    const inlineRow = document.createElement('div'); inlineRow.style = 'display:flex;align-items:center;gap:8px;';
    // audio element (shortened to fit)
    let a = null;
    if (meta.url){
      a = document.createElement('audio'); a.controls = true; a.src = meta.url;
      // allow audio control to flex/grow to fill remaining horizontal space
      a.style.flex = '1 1 auto'; a.style.width = 'auto'; a.style.maxWidth = 'none'; a.style.minWidth = '140px'; a.style.display = 'block';
    } else {
      a = document.createElement('div'); a.textContent = 'ï¼ˆéŸ³å£°ãªã—ï¼‰'; a.style.color = '#666';
    }
    const audioWrap = document.createElement('div');
    audioWrap.style = 'display:flex;align-items:center;gap:4px;flex:1 1 auto;min-width:0;';
    audioWrap.appendChild(a);
    const timestampEl = document.createElement('span');
    timestampEl.className = 'rec-timestamp';
    timestampEl.style = 'font-size:0.85rem;color:#6b7280;white-space:nowrap;flex:0 0 auto;';
    audioWrap.appendChild(timestampEl);
  const controls = document.createElement('div'); controls.style = 'display:flex;gap:8px;align-items:center;flex:0 0 auto;';
  const delBtn = document.createElement('button'); delBtn.textContent = 'éŒ²éŸ³å‰Šé™¤'; delBtn.style.background = '#e53e3e';
    controls.appendChild(delBtn);
    inlineRow.appendChild(audioWrap); inlineRow.appendChild(controls);
    right.appendChild(inlineRow);

  const summary = document.createElement('div'); summary.className = 'rec-summary'; summary.style = 'margin-top:6px;color:#333;font-size:0.95rem;'; summary.innerHTML = '';
  right.appendChild(summary);

    // word-level table (hidden initially)
    const wordsContainer = document.createElement('div'); wordsContainer.className = 'word-table'; wordsContainer.style.display = 'none';
    wordsContainer.innerHTML = `<table style="width:100%;border-collapse:collapse;"><thead><tr><th>å˜èª</th><th>ã‚¹ã‚³ã‚¢</th><th>åˆ¤å®š</th></tr></thead><tbody></tbody></table>`;
    right.appendChild(wordsContainer);

    // wire up buttons
    delBtn.onclick = async ()=>{
      if (!meta.key) { wrapper.remove(); updateEntrySummary(sectionIdx); return; }
    if (!confirm('ã“ã®éŒ²éŸ³ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) return;
  const resp = await authedFetch('/api/upload?key=' + encodeURIComponent(meta.key), { method: 'DELETE' });
    if (resp.ok) { wrapper.remove(); updateEntrySummary(sectionIdx); } else { alert('éŒ²éŸ³å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ'); }
    };
    toggleWordsBtn.onclick = ()=>{
      try{
        const wc = wrapper.querySelector('.word-table');
        if (!wc) return;
        if (wc.style.display === 'none' || wc.style.display === ''){ wc.style.display = 'block'; toggleWordsBtn.textContent = 'éš ã™'; }
        else { wc.style.display = 'none'; toggleWordsBtn.textContent = 'å˜èª'; }
      }catch(e){ console.warn('toggleWordsBtn', e); }
    };

    wrapper.appendChild(left);
    wrapper.appendChild(right);
    listEl.appendChild(wrapper);
    const tsIso = (() => {
      if (meta && meta.lastModified) {
        const dt = new Date(meta.lastModified);
        if (!Number.isNaN(dt.getTime())) return dt.toISOString();
      }
      return new Date().toISOString();
    })();
    setCardTimestamp(wrapper, tsIso);
    reorderRecordingList(listEl);
    updateEntrySummary(sectionIdx);
    // ensure only our donut canvas remains in the card (remove stray canvases)
    canvas.classList.add('rec-donut');
    const allCanvases = wrapper.querySelectorAll('canvas');
    allCanvases.forEach(c => { if (!c.classList.contains('rec-donut')) c.remove(); });
    // draw initial placeholder donut
    drawDonutOnCanvas(canvas, null);
  }catch(e){ console.warn('addRecordingCard error', e); }
}

// mark an existing card as assessed and attach short summary (and store full result on element)
function markCardAssessed(sectionIdx, s3Key, assessJson, savedAt){
  try{
    const listEl = document.getElementById(`recList_${sectionIdx}`); if (!listEl) return;
    const card = listEl.querySelector(`[data-s3key="${s3Key}"]`);
    if (!card) return;
    card.dataset.assessed = 'true';
    const summary = card.querySelector('div');
    // try to pull a numeric score
  const nb = (assessJson && (assessJson.result || assessJson))?.result || assessJson?.result || assessJson;
    // find first score value tolerant
    let score = null;
    try{ const s = (assessJson?.result?.NBest?.[0]) || (assessJson?.NBest?.[0]) || assessJson; score = s?.PronunciationAssessment?.PronScore ?? s?.PronScore ?? s?.PronunciationScore ?? s?.Score ?? null; }catch(e){}
    const summaryEl = card.querySelector('.rec-summary') || card.querySelector('.right > .rec-summary') || card.lastElementChild;
    if (summaryEl) summaryEl.innerHTML = '';
    card.__assessment = assessJson;
    // draw donut on card canvas
    try{
      const canvas = card.querySelector('canvas');
      if (canvas){ drawDonutOnCanvas(canvas, Number(score)); }
    }catch(e){}
    // populate word table if available; enable the toggle button when words exist
    try{
      const root = pickNBestRoot(assessJson) || pickNBestRoot(assessJson?.result) || pickNBestRoot(assessJson?.result?.result) || null;
      let words = [];
      if (root && Array.isArray(root.NBest) && root.NBest[0]){
        words = root.NBest[0].Words || root.NBest[0].PronunciationAssessment?.Words || [];
      } else if (assessJson && Array.isArray(assessJson.NBest) && assessJson.NBest[0]){
        words = assessJson.NBest[0].Words || assessJson.NBest[0].PronunciationAssessment?.Words || [];
      } else if (assessJson && assessJson.Words && Array.isArray(assessJson.Words)){
        words = assessJson.Words;
      }
    const wordsTable = card.querySelector('.word-table tbody');
      if (wordsTable){
        wordsTable.innerHTML = '';
        for (const w of words){
          const wa = w.PronunciationAssessment || w;
          const wordText = w.Word || w.Display || w?.WordText || '';
          const acc = (wa && (wa.AccuracyScore ?? wa.AccScore ?? wa.PronunciationAssessment?.AccuracyScore)) ?? 'N/A';
          const errorType = wa?.ErrorType || wa?.PronunciationAssessment?.ErrorType || 'None';
          const label = { 'None':'âœ… æ­£ã—ãç™ºéŸ³','Omission':'âš ï¸ è„±è½','Mispronunciation':'ğŸŒ€ èª¤ã‚Š','Insertion':'â• æŒ¿å…¥' }[errorType] || errorType;
          const tr = document.createElement('tr');
          tr.innerHTML = `<td style="text-align:center">${wordText}</td><td style="text-align:center"><strong>${acc}</strong></td><td style="text-align:center">${label}</td>`;
          wordsTable.appendChild(tr);
        }
        const wc = card.querySelector('.word-table');
        if (wc){
          // keep hidden by default, but enable toggle button
          wc.style.display = 'none';
          const tb = card.querySelector('.toggle-words-btn'); if (tb) { tb.disabled = false; tb.textContent = 'å˜èª'; }
        }
      }
    }catch(e){ console.warn('markCardAssessed word table', e); }
    if (savedAt) setCardTimestamp(card, savedAt);
    reorderRecordingList(listEl);
    updateEntrySummary(sectionIdx);
  }catch(e){ console.warn('markCardAssessed', e); }
}

// draw donut/arc on the given canvas; if score is null, show hollow gray circle
function drawDonutOnCanvas(canvas, score){
  try{
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height; const cx = w/2, cy = h/2, r = Math.min(w,h)/2 - 6;
    ctx.clearRect(0,0,w,h);
    // background track
    ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.strokeStyle = '#eee'; ctx.lineWidth = 8; ctx.stroke();
    if (score === null || score === undefined || Number.isNaN(Number(score))){
      // placeholder center text
      ctx.font = '12px sans-serif'; ctx.fillStyle = '#666'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('N/A', cx, cy);
      return;
    }
    const p = Math.max(0, Math.min(1, Number(score)/100));
    const start = -0.5*Math.PI, end = start + p * Math.PI * 2;
    // gradient stroke
    const grad = ctx.createLinearGradient(0,0,w,h); grad.addColorStop(0,'#f97316'); grad.addColorStop(1,'#4caf50');
    ctx.beginPath(); ctx.arc(cx,cy,r,start,end); ctx.strokeStyle = grad; ctx.lineWidth = 8; ctx.lineCap = 'round'; ctx.stroke();
  ctx.font = 'bold 16px sans-serif'; ctx.fillStyle = '#222'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText((Number(score).toFixed(1)), cx, cy);
  }catch(e){ console.warn('drawDonutOnCanvas', e); }
}

// helper: find the NBest-containing root object for various Azure response shapes
function pickNBestRoot(obj){
  if (!obj || typeof obj !== 'object') return null;
  if (Array.isArray(obj.NBest) && obj.NBest.length) return obj;
  if (obj.result && Array.isArray(obj.result.NBest) && obj.result.NBest.length) return obj.result;
  if (obj.result && obj.result.result && Array.isArray(obj.result.result.NBest) && obj.result.result.NBest.length) return obj.result.result;
  // sometimes the payload is already the NBest array
  if (Array.isArray(obj) && obj.length && obj[0] && (obj[0].Words || obj[0].Word)) return { NBest: obj };
  // fallbacks
  if (obj.NBest && Array.isArray(obj.NBest)) return obj;
  return null;
}

(async function bootstrap(){
  try {
    await ensureAuthenticated();
    currentAuthUserId = authState.userId;
    PAGE_PREFIX = computePagePrefix();
    buildSections();
  } catch (e) {
    console.error('initialization failed', e);
  }
})();

</script>

</body>
</html>